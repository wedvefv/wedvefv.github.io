(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{499:function(t,e,r){"use strict";r.r(e);var m=r(56),o=Object(m.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"redis常见问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis常见问题"}},[t._v("#")]),t._v(" redis常见问题")]),t._v(" "),r("h2",{attrs:{id:"rdb保存失败"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rdb保存失败"}},[t._v("#")]),t._v(" RDB保存失败")]),t._v(" "),r("p",[t._v("RDB保存会fock子进程，如果分配的内存由于linux系统的优化导致分配失败， 也就是系统有，但是觉得分配了会影响其他进程就不给你。")]),t._v(" "),r("p",[t._v("处理办法：")]),t._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("修改sysctl.conf文件，\n\nsudo vim /etc/sysctl.conf\n添加配置：\n\nvm.overcommit_memory=1 \n执行命令，使其生效\n\nsudo sysctl -p /etc/sysctl.conf\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br"),r("span",{staticClass:"line-number"},[t._v("7")]),r("br"),r("span",{staticClass:"line-number"},[t._v("8")]),r("br"),r("span",{staticClass:"line-number"},[t._v("9")]),r("br")])]),r("h2",{attrs:{id:"centos系统参数相关解释"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#centos系统参数相关解释"}},[t._v("#")]),t._v(" centos系统参数相关解释")]),t._v(" "),r("p",[t._v("overcommit_memory、overcommit_ratio、CommitLimit、Committed_AS概念")]),t._v(" "),r("p",[t._v("overcommit_memory是一个内核对内存分配的一种策略。")]),t._v(" "),r("p",[t._v("overcommit_memory取值有三种分别为0， 1， 2。")]),t._v(" "),r("p",[t._v("overcommit_memory=0， 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。")]),t._v(" "),r("p",[t._v("overcommit_memory=1， 表示内核允许分配所有的物理内存，而不管当前的内存状态如何，即：用户申请内存的时候，系统不进行任何检查任务内存足够用，直到使用内存超过可用内存。使用这个设置会增大内存超载的可能性，也可以增强大量使用内存任务的性能。")]),t._v(" "),r("p",[t._v("overcommit_memory=2，表示内核允许分配超过所有物理内存和交换空间总和的内存，但不允许超过虚拟内存限值（CommitLimit）的大小。如果您希望减小内存过度使用的风险，这个设置就是最好的。")]),t._v(" "),r("p",[t._v("overcommit_ratio是什么？")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("当overcommit_memory=2的时候，它一般代表的是系统中总的内存的百分比。\n")])])]),r("p",[t._v("虚拟内存限值（CommitLimit）")]),t._v(" "),r("p",[t._v("CommitLimit  = SwapTotal  +  MemTotal * overcommit_ratio")]),t._v(" "),r("p",[t._v("总的虚拟内存 = 总的交换分区 +  总的物理内存 * overcommit_ratio\n这些信息可以到cat /proc/meminfo中看到，可以通过上述的计算公式可以计算就可以获得系统的CommitLimit的值。")]),t._v(" "),r("p",[t._v("Committed_AS:是什么？")]),t._v(" "),r("p",[t._v("Committed_AS代表了系统已经分配的内存情况。")]),t._v(" "),r("p",[t._v("overcommit_memory的系统默认值是0，overcommit_ratio的默认值是50。")]),t._v(" "),r("p",[t._v("所以实际中会遇到相同配置的电脑，相同的程序一个可以申请到内存，一个不可以申请到。这时候可以看看overcommit_memory的值是否被修改了。")]),t._v(" "),r("p",[t._v("overcommit_memory=2的使用场景：")]),t._v(" "),r("p",[t._v("CommitLimit为当前系统可以申请的总内存，Committed_AS为当前已经申请的内存，记住是申请。")]),t._v(" "),r("p",[t._v("因此当你的free查看有很多大量可用的内存的时候，实际Committed_AS可能已经申请了大量的内存了，在vm.overcommit_memory 2模式下，")]),t._v(" "),r("p",[t._v("后续的程序可以申请的剩余内存为CommitLimit - Commited_AS了。而vm.overcommit_memory设置为2一般是建议当Swap大于物理内存的时候才进行设置。")]),t._v(" "),r("p",[t._v("LTP测试用例中“overcommit_memory02”将“overcommit_ratio”设置为0，即为测试全部使用SwapTotal 的场景，而我们的swap空间为0。其他几个测试用例的意图也就是测试不同比例的内存过度使用的情况。")]),t._v(" "),r("h2",{attrs:{id:"参考博客"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考博客"}},[t._v("#")]),t._v(" 参考博客")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://blog.csdn.net/weixin_30709635/article/details/101201387",target:"_blank",rel:"noopener noreferrer"}},[t._v("redis fock内存不足"),r("OutboundLink")],1)]),t._v(" "),r("p",[r("a",{attrs:{href:"https://blog.csdn.net/gaojy19881225/article/details/80018527",target:"_blank",rel:"noopener noreferrer"}},[t._v("linux系统参数"),r("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=o.exports}}]);