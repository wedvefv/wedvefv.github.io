---
layout: post
title: python类的三种装饰器
category: python
date: 2019-02-14 14:00:00

---

## property装饰器作用和原理

* 1. 我们知道c++中有public,projected,private等修饰类私有属性的作用，这样就限定了某些属性只能读取，不能修改；有些能读也能需改。
* 2. 设置C++类中的一个属性可以自定义方法get和set方法。
* 3. python中实现这种原理，就需要装饰器property，本身可修饰（变量x同名）的函数，让x拥有可读的属性（相当于get函数
* 4. @property进而又生成一个@x.setter装饰器，在修饰一下属性x同名的函数就让x拥有可写的属性（相当于set函数）


## property 装饰器

```py
class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2014 - self._birth
        
    # birth 是一个可读可写的属性，age是只读属性。
    # property装饰器本身可以把getter方法变成属性，同时生成一个@birth.setter装饰器，可以修饰birth变成一个可设置的属性。
    # 但要注意这些额外函数的名字和 property 下的一样，例如这里的 birth,age。
```


## 一种古老的用法，使用内置函数property实现如下，和上面的方法一样。

```py
class Animal(object):
    def __init__(self, name, age):
        self._name = name
        self._age = age
        self._color = 'Black'

    def get_name(self):
        return self._name

    def set_name(self, value):
        if isinstance(value, basestring):
            self._name = value
        else:
            self._name = 'No name'

    name = property(fget=get_name, fset=set_name, fdel=None, doc='name of an animal')

    def get_age(self):
        return self._age

    def set_age(self, value):
        if value > 0 and value < 100:
            self._age = value
        else:
            self._age = 0
            # print 'invalid age value.'

    age = property(fget=get_age, fset=set_age, fdel=None, doc='name of an animal')
    

a = Animal('black dog', 3)
a.name = 'white dog'
a.age = 3
print 'Name:', a.name
print Animal.name.__doc__
print 'Age:', a.age
```



