---
layout: post
title: flask 第1章(基本结构和概念)
category: flask
date: 2019-01-28 22:22:00

---

# 开始和程序基本结构

## 1.首先安装虚拟环境包和git工具

* sudo apt-get install python-virtualenv
* sudo apt-get install git

## 2.创建一个目录

* mkdir flask_learn
* cd flask_learn

## 3.下载实例代码
* git clone http://github.com/miguelgrinberg/flasky.git
* cd flask
* 建立一个虚拟环境
* virtualenv venv
* 激活虚拟环境
* source venv/bin/activate
* 取消激活分区
* deactivate
* 虚拟环境下安装pip
* pip install flask
* 切换分支
* git checkout 2a

```py
from flask import Flask
app = Flask(__name__)


@app.route('/')
def index():
    return '<h1>Hello World!</h1>'

if __name__ == "__main__":
    app.run(debug=True)

```
* 执行 python hello.py
* 浏览器输入http://127.0.0.1:5000/ 就可以看到helloword了。
* 但是这样会出现一个问题。你在linux虚拟机里面执行的代码。在window上浏览器看就不行，需要设置
* 如下改动 app.run(debug=True，host="0.0.0.0")或者使用manage模块扩展传参数，后面会提到。

## 4. flask程序有四个上下文
* curent_app  程序上下文， 当前激活的程序实例
* g 程序上下文 处理请求的临时存储对象，每次请求都会重设这个变量。
* request  请求上下文    请求对象，封装了每次http请求的内容
* sesion  请求上下文    用户会话， 用于存储之间需要记住的值的词典。
* 这是个变量每次请求 都是独立属于这一次请求的，或者说是属于同一个线程内全局可见。

## 5. 请求调度

*	这个主要是 url和处理函数的映射关系，即视图。
*	通过app.url_map 可以看到映射关系。
*	生成映射的方法2中，1 app.route修饰器 2，app.add_url_rule()

## 6. 请求钩子

* 主要是为了每个请求开始可能都需要认证，数据库连接等重复操作的代码复。
* 通过钩子装饰器，注册函数，在到达视图函数前运行这些函数。
* 有四种个钩子 brefore_first_request,brefore_request,after_request,teardown_request
> after_request 有没做处理的异常抛出时，是不运行的。
> teardown_request 即使有没处理的异常抛出，也会运行。


## 7. 响应

* flask 默认返回200 状态吗
* 可以返回其他状态吗
```py
return "hello word!", 400
或者
return "hello world!", 500, {"ua":10}
返回的是一个元组，第二个是状态吗，第三个是header，字典形式。
```

* 还可以使用make_response("hello world!", 500, {"ua":10})生成一个对象，以便调用函数设置cookie等其他值。
* 320重定向，使用redirect("www.baidu.com")函数。
* 特殊响应，比如404 可以使用abort(404)函数，这个直接就吧控制权交给web服务器了，不会再调用其它函数。

## 8. flask扩展

* pip install flask-script

* 用manager吧app对象包住，这样就可以使用manager扩展了。

```py
from flask import Flask
from flask_script import Manager

app = Flask(__name__)

manager = Manager(app)


@app.route('/')
def index():
    return '<h1>Hello World!</h1>'


@app.route('/user/<name>')
def user(name):
    return '<h1>Hello, %s!</h1>' % name


if __name__ == '__main__':
    manager.run()

```

* 启动服务：
> python hello.py  runserver --host 0.0.0.0


## 9 模板的继承

* 类似于python中的类的继承
* 首先需要一个基类模板base.html 然后把对应的可修改的块用  {%block X %} {%endblock%} 格式包含即可。

```py
<html>
  <haed>
  {% block  head%}  {%endblock%}
  {% block title%} {%endblock%}
  </head>
  <body>
    {%block body%}  {%endblock%}
  </body>
</html>
```
* 在子类模板中使用基类模板

```py
{%extends "base.html"% }

{%block title%} 这是index标题 {%endblock%}

{%block head%}
  {{super()}}   #基类head部分原本的内容用supper获取
  <style>
  </style>
{%endblock%}

{%block body%}
  <h1> hello world </h1>
{%endblock%}
```
