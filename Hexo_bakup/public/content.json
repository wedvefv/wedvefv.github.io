{"meta":{"title":"时光","subtitle":"记录时光","description":"愿你出走半生，归来仍是少年！","author":"wedvefv","url":"http://wedvefv.github.io"},"pages":[{"title":"about","date":"2018-05-01T09:10:48.000Z","updated":"2019-03-02T10:16:38.005Z","comments":true,"path":"about/index.html","permalink":"http://wedvefv.github.io/about/index.html","excerpt":"","text":"Welcome to rlovep! This is my bolg;weibo for more info. If you get any problems when see this page, you can find the answer in csdn or you can ask me on GitHub. ##"},{"title":"tags","date":"2019-05-19T14:51:01.000Z","updated":"2019-05-19T14:51:01.293Z","comments":true,"path":"tags/index.html","permalink":"http://wedvefv.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一张导图了解cookie和session","slug":"ngx_lua/cookie_and_session","date":"2019-06-09T13:50:00.000Z","updated":"2019-06-09T13:52:51.990Z","comments":true,"path":"2019/06/09/ngx_lua/cookie_and_session/","link":"","permalink":"http://wedvefv.github.io/2019/06/09/ngx_lua/cookie_and_session/","excerpt":"","text":"cookie和session的区别","categories":[{"name":"nginx","slug":"nginx","permalink":"http://wedvefv.github.io/categories/nginx/"}],"tags":[]},{"title":"一张图看懂centos6和7的启动流程区别","slug":"linux/centos6和7的启动流程","date":"2019-06-09T02:34:58.000Z","updated":"2019-06-09T10:08:52.957Z","comments":true,"path":"2019/06/09/linux/centos6和7的启动流程/","link":"","permalink":"http://wedvefv.github.io/2019/06/09/linux/centos6和7的启动流程/","excerpt":"","text":"启动流程","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://wedvefv.github.io/tags/hexo/"}]},{"title":"如何在centos7中添加开机启动项","slug":"linux/一文了解linux开机启动","date":"2019-06-08T02:34:58.000Z","updated":"2019-06-09T00:33:51.058Z","comments":true,"path":"2019/06/08/linux/一文了解linux开机启动/","link":"","permalink":"http://wedvefv.github.io/2019/06/08/linux/一文了解linux开机启动/","excerpt":"","text":"1. linux的启动等级0 关机模式1 单用户模式2 无网络多用户模式3 有网络多用户模式，如果没网络和2一样。4.系统保留，未使用5.GUI图形界面6.重启模式，默认不能是这个级别，否则就会无限循环重启 正常默认就是3了, 命令行模式，有桌面的，应该默认是5. 关机就可以终端输入init 0，重启就init 6 7.默认级别在centos7之前是/etc/inittab文件设置的，之后就由systemctl接管了 查看默认运行级别的方式为: systemctl get-default 设置默认运行级别的方式: systemctl set-default TARGET.target 级别分别对应如下: shutdown.target emergency.target rescure.target multi-user.target 无 graphical.target 无 2. 每个等级，系统初始化运行了哪些脚本呢 /etc/init.d/ 目录是个软连接 实际是/etc/rc.d/init.d /etc/rc1.d/ /etc/rc2.d/ /etc/rc3.d/ /etc/rc4.d/ /etc/rc5.d/ /etc/rc6.d/ 以上6个目录也都是软连接，实际是/etc/rc.d/目录下的 最终就是/etc/rc.d/init.d/ 和/etc/rc.d/rcX.d/目录了 但是rcX.d/目录下的文件实质也是软连接，指向/etc/rc.d/init.d/目录下的脚本 3. 添加开机启动项(chkconfig) 经过之前的分析，实际上就是/etc/rc.d/init.d 目录下的东东，分析发现 都是shell脚本 脚本 按自己的操作写就ok 比如你写一个nginx自启动的脚本/etc/rc.d/init.d/nginx 12345678910111213141516171819202122#! /bin/bash#chkconfig: 2345 80 90#description:auto_run. /etc/init.d/functionsif [ \"$1\" == \"start\" ]; then /usr/local/openresty/nginx/sbin/nginx exit 0fiif [ \"$1\" == \"stop\" ]; then /usr/local/openresty/nginx/sbin/nginx -s stop exit 0fiif [[ $1 == 'reload' ]]; then /usr/local/openresty/nginx/sbin/nginx -s reload exit 0fiecho \"sh nginx start|stop|reload\" chmod +x nginx chkconfig –add nginx (老写法：chkconfig nginx on) 这样在对应等级rcX.d/目录下就会生成对应的链接，K开头脚本这个服务关闭，S开头的脚本是这个服务要开启. 每个添加的自启动脚本必须要有2行注释： #chkconfig: 2345 80 90 #description:nginx_test 可以随便写描述 centos7 开头这么加也可以 123456789### BEGIN INIT INFO# Provides: php-fpm# Required-Start: $remote_fs $network# Required-Stop: $remote_fs $network# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: starts php-fpm# Description: starts the PHP FastCGI Process Manager daemon### END INIT INFO 解释下: 2345表示四个启动等级可以需要运行nginx服务; 在rc2|3|4|5.d目录下生成S80nginx脚本，rc0|6.d目录下生成K90nginx脚本都指向/etc/rc.d/init.d/nginx脚本（80，90为了标识脚本含义是开启还是关闭，虽然脚本内容一样，但是K开头执行时加参数 stop，S开头的执行时加参数 start） 4. 在rc.local文件中添加启动项 /etc/rc.d/init.d/rc.local 这个是init.d–&gt; rc.d 执行或之后执行的脚本，通常是用户自己定义的一些开机启动任务. 下次总结一下Centos6的启动顺序","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://wedvefv.github.io/tags/hexo/"}]},{"title":"python 编码reload(sys)的作用","slug":"language/python/3_reload_sys","date":"2019-05-02T06:00:00.000Z","updated":"2019-05-19T14:18:38.609Z","comments":true,"path":"2019/05/02/language/python/3_reload_sys/","link":"","permalink":"http://wedvefv.github.io/2019/05/02/language/python/3_reload_sys/","excerpt":"","text":"为什么需要sys.setdefaultencoding(“utf-8”) 因为python转码是通过unicode作为中间码的。 比如字符串 x = “你们”，本身是str，首先我们指定了文件编码uft8，所以x是utf8编码的。 如果要转化gb18030， 默认是x用默认解码方式（ASCII）decode成中间码 unicode -&gt; encode成gb18030 如果x是abc这些ascii字符本身ascii和utf8方式是一样的,不会报错; 但是x是中文，就不能按ascii方式解码了。。怎么办呢？ 1 . 自己指定解码方式，在编码 1y = x.decode(\"utf-8\").encode(\"gb18030\") 2.开头设置默认编解码方式 123import sysreload(sys)sys.setdefaultencoding(\"utf-8\") 为什么reload(sys)呢 因为模块/lib/site.py删除了sys.setdefaultencoding这个函数。 site.py 有什么作用 是解释器初始化时自动导入的，这个模块的作用是：自动将第三方模块路径加入到sys.path中。 import的实质 import sys导入语句，只是导入了一个对sys的引用，因为别人已经提前导入了sys，后面的模块使用sys都是引用这个对象。 而作为初始化模块site.py,导入了许多内建模块包括sys，而且删除了sys.setdefaultencoding这个方法，后面你写的模块，只要导入sys,都是没有这个方法的。 所以需要reload一把，reload也是有前提的，就是之前已经加载过的模块，如果没有加载过的，就无重谈起重新加载了。","categories":[{"name":"python","slug":"python","permalink":"http://wedvefv.github.io/categories/python/"}],"tags":[]},{"title":"微信支付流程","slug":"language/html/weixin","date":"2019-04-13T01:40:00.000Z","updated":"2019-05-19T14:30:17.030Z","comments":true,"path":"2019/04/13/language/html/weixin/","link":"","permalink":"http://wedvefv.github.io/2019/04/13/language/html/weixin/","excerpt":"","text":"三个平台都有什么？ 微信公众平台: 微信官方平台，功能： 群发推送、自动回复、二维码订阅，用途：消息推送、品牌传播、分享 微信开放平台: 为第三方提供接口，比如分享朋友圈，发送给微信好友等 微信商户平台：主要是用于微信支付的，比如APP和公众号需要接入支付功能，就需要申请一个商户号。 前提 在开放平台，注册自己的app，通俗讲就是在微信备案一下。 客户端需要干嘛？ 需要下载微信安卓或者ios版SDK,集成到自己的app中，主要是为了调起微信支付模块。 app调起支付模块，需要传参数吧，不然请求微信服务器也不知道具体转给谁钱，转多少钱… 支付参数哪里来呢？服务器生成啊….. 支付完成后微信会返回微信订单号的信心，后期可以用于到微信服务器查询订单状态。 商户服务器需要干嘛，比如一个卖游戏点卡的app？给客户端提供接口 1.支付接口，这个接口需要以下业务功能 1.去查询用户是否存在，用户信息可以在redis中记录 2.如果某类商品，用户只能有一个产品生效的,比如点卡A,产品类别id为A 3.使用redis记录uid:goodsid[A]:hash记录这个购买的点卡x的信息,记录createtime，orderid，prepayid 4.如果uid对应点卡A的信息存在，且now - createtime &lt; 15分钟，说明微信没回调过来，是支付中…的状态。直接拿缓存中信息返回给客户端就可以了，供客户端调用支付模块。 5.如果uid对应的点卡信心不存在，就说明用户没买过这种A这类的商品,生成28位的订单号作为out_trade_no参数，其他参数按规定设置，然后调用微信统一下单接口 https://api.mch.weixin.qq.com/pay/unifiedorder 当前商户服务器统一下单的过程中，需要用mysql记录自己的订单信息、更新用户的余额扣减、记录一些用户订购该类产品的缓存信息等；mysql数据用于支付完成后，微信发起异步回调状态时更新订单状态。 7.下单后生成预支付id：prepayid，因为还没有真正调起支付模块，只是微信那边现生成一个预支付回话id。 8.有了prepayid加上其他参数，返回给客户端用于真正调起sdk支付模块。 9.调完支付模块后，微信服务器会立刻返回到app中，这时候客户端需要实现onResp回调函数，如果支付成功，需要去服务器查询是否真的ok，永远以服务端返回的支付结果为准。 2.主动查询订单接口 1.需要知道我们自己分配的订单orderid，和uid，从mysql获取缓存，校验orderid和uid是不是对应同一个人。 2.查到mysql记录的这个订单状态还是支付中，就用orderid，微信推荐优先使用微信订单号，如果这个字段缺少就用商户的订单号。 3.调起微信查询url https://api.mch.weixin.qq.com/pay/orderquery，判断返回结果，然后事务操作（更新mysql订单状态，及用户金钱信息余额等）。 回调接口（给微信服务器使用，用于回调支付状态） 1.我们首先查询订单状态是否为1支付中的状态，如果不是，说明失败，或者成功了，不与理会 2.如果数据return_code或者result_code不全是SUCCESS，直接按对应格式返回成功 3.如果都是SUCCESS，校验WXPAY_SECKEY，APPID，MCHID。 4.都通过了,则事务操作（更新mysql订单状态，及用户金钱信息余额等）,修改必要的缓存。","categories":[{"name":"微信支付","slug":"微信支付","permalink":"http://wedvefv.github.io/categories/微信支付/"}],"tags":[]},{"title":"简单总结一下加密算法AES-DES-RAS-DSA-ECDSA-ECC","slug":"linux/AES_RSA_DSA","date":"2019-03-02T04:00:00.000Z","updated":"2019-05-19T14:18:38.605Z","comments":true,"path":"2019/03/02/linux/AES_RSA_DSA/","link":"","permalink":"http://wedvefv.github.io/2019/03/02/linux/AES_RSA_DSA/","excerpt":"","text":"加密体系对称加密算法，加密和机密密钥一样，加密方和解密方都持有. DES加密 56位密钥长度，美国数据加密标准，DES算法的入口参数有三个：Key、Data、Mode。其中Key为7个字节共56位，是DES算法的工作密钥；Data为8个字节64位，是要被加密或被解密的数据；Mode为DES的工作方式,有两种:加密或解密。 AES加密 高级加密标准，一种区块加密算法,为了取代DES。 二者的优点是加密快，资源消耗少，但是AES比DES安全。 非对称加密算法 RSA，基于数学原理，一个极大数做质数(也叫素数)分解很困难;简单讲,就是你根据公钥很难计算出私钥，因为解密需要接受者的私钥。rsa 由于密钥长度大，加密慢，所以一般只加密产生的会话密钥，会话秘钥才用于加密来加密数据。 DSA(DSS), 签名算法， DSA是基于整数有限域离散对数难题的，其安全性与RSA相比差不多。DSA的一个重要特点是两个素数公开，这样，当使用别人的p和q时，即使不知道私钥，你也能确认它们是否是随机产生的，还是作了手脚。RSA算法却做不到 ECC 椭圆加密算法， 其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性，主要优势是比其他方式如RSA使用更短的密钥长度，达到同等安全级别，优点就是别rsa，dsa快，存储空间小，贷款要求低。 演变而来的ECDSA（ECC+DSA）数字签名算法，是ECC对DSA的一种模拟实现，ECC是椭圆的离散对数问题，DSA也是对数问题。只不过使用签名采用ECC算法，输出也是2个值，r和s 其他算法 md5: 消息摘要算法，防止数据被篡改。 sha系列，安全散列算法，也是散列函数，应用于信息安全和数字签名领域，都是不需要解密的，也无法解密。","categories":[{"name":"加密算法","slug":"加密算法","permalink":"http://wedvefv.github.io/categories/加密算法/"}],"tags":[]},{"title":"git_tag用法","slug":"linux/git_tag用法","date":"2019-03-02T04:00:00.000Z","updated":"2019-05-19T14:18:38.608Z","comments":true,"path":"2019/03/02/linux/git_tag用法/","link":"","permalink":"http://wedvefv.github.io/2019/03/02/linux/git_tag用法/","excerpt":"","text":"tag 和branch的区别 Git tag是一系列commit的中的一个点，只能查看，不能移动。 branch是一系列串联的commit的线。 git tag的用法 我们常常在代码封板时,使用git 创建一个tag ,这样一个不可修改的历史代码版本就像被我们封存起来一样,不论是运维发布拉取,或者以后的代码版本管理,都是十分方便的 git的tag功能 git 下打标签其实有2种情况轻量级的：它其实是一个独立的分支,或者说是一个不可变的分支.指向特定提交对象的引用 带附注的：实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证,电子邮件地址和日期，一般我们都建议使用含附注型的标签，以便保留相关信息所以我们推荐使用第二种标签形式 创建tag git tag -a V1.2 -m ‘release 1.2’ 上面的命令我们成功创建了本地一个版本 V1.2 ,并且添加了附注信息 ‘release 1.2’ 查看tag git tag 要显示附注信息,我们需要用 show 指令来查看 git show V1.2 但是目前这个标签仅仅是提交到了本地git仓库.如何同步到远程代码库 git push origin –tags 如果刚刚同步上去,你缺发现一个致命bug ,需要重新打版本,现在还为时不晚. git tag -d V1.2 到这一步我们只是删除了本地 V1.2的版本,可是线上V1.2的版本还是存在,如何办?这时我们可以推送的空的同名版本到线下,达到删除线上版本的目标: git push origin :refs/tags/V1.2 如何获取远程版本? git fetch origin tag V1.2 这样我们可以精准拉取指定的某一个版本.适用于运维同学部署指定版本.","categories":[{"name":"git","slug":"git","permalink":"http://wedvefv.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://wedvefv.github.io/tags/git/"}]},{"title":"git_linux搭建服务器","slug":"linux/git_linux搭建服务器","date":"2019-03-02T04:00:00.000Z","updated":"2019-05-19T14:18:38.608Z","comments":true,"path":"2019/03/02/linux/git_linux搭建服务器/","link":"","permalink":"http://wedvefv.github.io/2019/03/02/linux/git_linux搭建服务器/","excerpt":"","text":"为什么本地搭建一个git服务器 对于自己学习使用的代码，在没有网络的情况下不能用github，gitlab,所以本地建立一个git服务器。 git服务器环境准备centos7服务端创建git用户1234id git # 查看是否存在git用户，存在就不创建了。useradd gitpasswd git输入密码，我设置的是xxx@123 客户端开启公钥认证认证，免密push/pull 首先服务端需要开启ssh服务 12345vim /etc/ssh/sshd_configRSAAuthentication yes PubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys如果是centos7.4以上（含7.4），ssh1已经不支持了，只支持ssh2代协议。所以RSAAuthentication项是没有的 客户端执行 执行ssh-keygen -t rsa 生成公钥和私钥 复制客户端公钥到服务器端ssh-copy-id -i ~/.ssh/id_rsa.pub git@192.168.61.128 服务端创建git仓库12345678mkdir -p /data/git/gittest.git# 初始化这个仓库cd /data/git/gittest.gitgit init --bare .# 目录所属用户设置chown -R git:git /data/git 客户端clone远程仓库12345678910mkdir localgitcd localgitgit clone git@192.168.61.128:/data/git/gittest.git .# 提示输入服务端git账户的密码。#修改完就可以提交了touch abc.txtgit add .git commit -m 'aaa'git push","categories":[{"name":"git","slug":"git","permalink":"http://wedvefv.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://wedvefv.github.io/tags/git/"}]},{"title":"redis文章发布","slug":"db/redis/redis文章发布","date":"2019-02-22T07:50:00.000Z","updated":"2019-05-19T14:18:38.609Z","comments":true,"path":"2019/02/22/db/redis/redis文章发布/","link":"","permalink":"http://wedvefv.github.io/2019/02/22/db/redis/redis文章发布/","excerpt":"","text":"定时任务发布方式 如果有后台发布文章，需要有定时任务将mysql中录入的文章同步到redis中 这时候文章id当然是mysql自增产生的，生成一个文章id表示的文章内容 123456 conn.hmset(\"article:100:hash\",&#123;属性字典&#125;）``` - 2. 作者发布的文章，文章的投票者集合当然有作者，需要设置投票集合。```py conn.sadd(\"artile:100:set\",atrticle.uid) conn.expire(\"artile:100:set\",7*86400) # 一周有效期 文章的评分zset初始化,文章发布时间集合初始化。12conn.zincrby(\"article:100:score:zset\",432)， 432 是一个投票的评分。conn.zadd(\"article:time:zset\",article_id, now) 如果是没有mysql，完全用redis这时候，文章id就需要一个string类型的key自增产生，其余步骤一致。","categories":[{"name":"redis","slug":"redis","permalink":"http://wedvefv.github.io/categories/redis/"}],"tags":[]},{"title":"redis文章投票","slug":"db/redis/redis文章投票","date":"2019-02-22T07:50:00.000Z","updated":"2019-05-19T14:18:38.609Z","comments":true,"path":"2019/02/22/db/redis/redis文章投票/","link":"","permalink":"http://wedvefv.github.io/2019/02/22/db/redis/redis文章投票/","excerpt":"","text":"1. 文章信息可以用hash表示 比如文章id为key，文章属性为filed，属性值为value 1234key : articel:1 title : 这是标题link： www.baidu.comupdatetime: 2019-02-21 00:00:00 也可以用大的hash，每个filed是一个文章id，value是一个json表示文章属性， 2. 文章id和发布时间对应关系用zset表示 文章id对应member，发布时间是score 3. 文章id和文章评分对应关系也可用zset表示 文章id对应member， 分数对应score 4. 对一篇文章首次投票之后，发生什么变化？ 有时只需要7天之内发布的文章才可以投票，否则直接返回。 用户是不支持重复投票的，所有应该有一个文章id对应的set类型的key，将投过票的uid加入到里面，如果加入失败，就说明重复了，就不增加评分。 首先对应文章id的评分增加，具体增加规则： 将文章的已获得的支持票数*一个常量 +发布时间戳；常量可以432（86400/200）200个投票需求，平均一天时间。，这只是我见到的一个方法。 增加文章的投票+1，使用hincrby ，前提是如果用hash记录文章属性的话，投票数就是一个属性。 考虑到并发，如果以上三个操作应该用事物操作，保证原子性。","categories":[{"name":"redis","slug":"redis","permalink":"http://wedvefv.github.io/categories/redis/"}],"tags":[]},{"title":"redis文章分组的用途","slug":"db/redis/redis文章分组的用途","date":"2019-02-22T07:50:00.000Z","updated":"2019-05-19T14:18:38.609Z","comments":true,"path":"2019/02/22/db/redis/redis文章分组的用途/","link":"","permalink":"http://wedvefv.github.io/2019/02/22/db/redis/redis文章分组的用途/","excerpt":"","text":"文章分组的用途 文章分组，可以用set结构存储同一个分组的文章id set可以和zset使用zinterstore命令求交集，set默认的score是1， zset默认的一般不是1，可以指定参数max，取score大的值。 比如获取一个分组A中的文章按时间排序，就拿这个分组和发布时间集合zset求交集，交集可以取一个临时名字，设置有效期60s。 比如获取一个分组B中的文章按照评分大小排序，就拿这个分组和评分集合zset求交集。 一般接口直接就拿redis获取的数据返回了。","categories":[{"name":"redis","slug":"redis","permalink":"http://wedvefv.github.io/categories/redis/"}],"tags":[]},{"title":"VM虚拟机三种联网模式区别","slug":"linux/Vm虚拟机的三种联网模式区别","date":"2019-02-21T08:00:00.000Z","updated":"2019-03-02T10:16:37.987Z","comments":true,"path":"2019/02/21/linux/Vm虚拟机的三种联网模式区别/","link":"","permalink":"http://wedvefv.github.io/2019/02/21/linux/Vm虚拟机的三种联网模式区别/","excerpt":"","text":"1.HOST-ONLY 对应图中的private to my Mac 选项 这种模式不能联网，能通过DHCP分配到ip地址，使用VMnet1网卡作为交换机，默认网关就是VMnet1的地址，能和主机通信，不能连接外网。 VMnet1网卡作为交换机，一个连接主机HOST，一个端口连接DHCP服务器（一个VM组件），剩下的链接虚拟机，没有提供NAT服务，所以没有路由功能。 2.NAT模式，网络地址转换 对应图中的 share with my Mac 选项 ，这是共享网络模式 这种模式，使用DHCP分配ip地址，使用VMnet8作为交换机，能与主机通信，能连接外网。 VMnet8网卡作为交换机，一个连接主机HOST，一个端口连接DHCP服务器（一个VM组件），一个端口连接NAT服务器（也是一个VM组件）。剩下端口的链接虚拟机。 以上模式，主要是NAT服务器的区别，导致一个能链接外网一个不能。 3.Bridged模式，（桥接模式） 就是图片中的Bridged NetWorking部分，可以看到有自动模式，WIFI模式，蓝牙模式，因为mac可以用多种方式联网。 这种模式对VMnet0，它相当于一个网桥，连接主机和虚拟机，这样虚拟机和你的主机就是两个对等的设备了，当然也是可以联网。 虚拟机vmnet0、vmnet1和vmnet8的区别","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[]},{"title":"nginx连接数和内核参数的联系","slug":"linux/nginx连接数和内核参数关系","date":"2019-02-16T04:06:00.000Z","updated":"2019-03-02T10:16:37.984Z","comments":true,"path":"2019/02/16/linux/nginx连接数和内核参数关系/","link":"","permalink":"http://wedvefv.github.io/2019/02/16/linux/nginx连接数和内核参数关系/","excerpt":"","text":"没明白呢。。","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[]},{"title":"tcp连接过程，半连接队列和全连接队列","slug":"linux/tcp半连接队列和全连接队列","date":"2019-02-15T04:06:00.000Z","updated":"2019-03-02T10:16:37.984Z","comments":true,"path":"2019/02/15/linux/tcp半连接队列和全连接队列/","link":"","permalink":"http://wedvefv.github.io/2019/02/15/linux/tcp半连接队列和全连接队列/","excerpt":"","text":"tcp三次握手的过程 第一次：客户端发送SYN(Synchronize Sequence Numbers)报文，标志位SYN=1,序列号seq=j。 第二次：服务端收到SYN报文后，回应ACK(Acknowledgement)，标志位ACK=1,确认号ack为j+1， 同时自己也发送一个SYN报文，SYN=1,序列号seq假设为k， 即一个ACK+SYN包 第三次：客户端收到报文后，发送一个ACK报文，标志位ACK=1，确认号ack=(k+1) 到服务器，客户端和服务器进入ESTABLISHED状态，TCP链接成功。 SYN是同步报文标志位，建立连接时为1，连接建立后置为0，ACK时确认标志位一般为1 tcp四次挥手过程，为什么是4次呢？ 假如客户端主动发起关闭操作 第一次： 客户端发送FIN报文，假设为序列号seq=i给服务器。 第二次： 服务发送ACK报文，ack=(i+1)给客户端，可能数据还没有接收完毕，所以服务端socket状态由ESTABLISHED -&gt; CLOSE_WAIT状态。 第三次： 服务端端处理完毕，发送FIN报文，序列号为j。 第四次： 客户端收到报文后，发送ACK报文，ack=j+1, 并进入TIME_WAIT状态。等待2MSL后自动关闭 为什么客户端不发完ack就释放呢，因为服务器可能没收到ack，服务器会重新发送FIN请求关闭连接，客户端重新发送ack，所以一个来回就是2个报文周期。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。 借用一张图表示一下 如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 查看网络链接的命令 查看不同状态的链接数 netstat -an | awk ‘/^tcp/ {++y[$NF]} END {for(w in y) print w, y[w]}’ 半连接状态队列sync_queue和全连接队列accept_queue 第一种实现： BSD实现和在linux2.2之前，listen系统调用backlog参数表示半链接+全链接队列数之和 当队列满了以后，服务端再收到SYN时，将不会返回SYN/ACK。比较优雅的处理方法就是不处理这条连接，不返回RST，让客户端重试. accept系统调用只是简单地从完成队列中取出连接. 第二种实现： linux内核2.2以上的版本，SYN_RCVD队列的大小由proc/sys/net/ipv4/tcp_max_syn_backlog系统参数指定，ESTABLISHED队列由backlog和/proc/sys/net/core/somaxconn中较小的指定 如果全连接队列满了怎么办？ 服务器不予处理，这样客户端会任务数据丢失，重新发送ack确认，如果服务器有空间，会重新加入到ESTABLISHED队列。 如果client端没收到服务器发来的FIN，那么client会一直是FIN_WAIT_2吗？ 设置系统变量 sysctl -w net.ipv4.tcp_fin_timeout=5 直接ctrl+c杀死客户端，发现FIN_WAIT_2的状态的链接，一会就消失了，并不会进入TIMEWAIT状态。 怎么查看链接状态呢？ 123netstat -natp | grep 8888#8888是服务端监听的端口，因为tcp链接总是有一端是8888端口的。 查看每个ip和服务器的连接数 1netstat -nat|awk '&#123;print$5&#125;'|awk -F : '&#123;print$1&#125;'|sort|uniq -c|sort -rn 什么是MSL呢？ linux上的定义，就是60s12#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT * state, about 60 seconds */ 全连接队列满了怎么办呢？ 服务器根据 /proc/sys/net/ipv4/tcp_abort_on_overflow的值处理 0 表示丢弃ack，让客户端重新发ack 1 表示表示发送一个RST给客户端，直接废弃掉这个握手过程，客户端会出现connection reset by peer的错误 tcp协议RFC文档 参考链接1 参考链接2 参考链接3 socket耗尽，半连接队列限制 参考链接4","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[]},{"title":"ip地址和子网掩码，广播地址关系","slug":"linux/ip地址子网掩码的关系","date":"2019-02-14T06:00:00.000Z","updated":"2019-03-02T10:16:37.989Z","comments":true,"path":"2019/02/14/linux/ip地址子网掩码的关系/","link":"","permalink":"http://wedvefv.github.io/2019/02/14/linux/ip地址子网掩码的关系/","excerpt":"","text":"什么是ip地址？ ip是在一个网段中的一台计算机的ip地址（192.168.1.2） 如果你家的联通宽带给你家的公网ip地址是10.10.123.234(假设的)，那么接到你家路由器，首先路由器需要有一个ip地址，一般是192.168.1.1（也可能是192.168.0.1），这个应该可以登录到路由器中设置。 其中192.168.1.255 就是广播地址，比如centos中ifconfig命令查看的broadcast 剩余的ip段192.168.1.2~192.168.1.254 就是可以分配给手机，电脑等客户端使用的ip。一共是253（255-2）个。 ip由什么组成？ 例如一个ip 192.168.1.2，是一个C类网络，一般有254台主机。二进制表示就是 网络号标识|1100 0000 |1000 0000| 0000 0001| + 主机号标识|0000 0010| 点号分割每个数字都是8位二进制,网络号部分就是192.168.1,主机号部分就是2。 网络标识部分越短，那么标识主机部分可用的范围越大，但是需要子网掩码配合决定由多少可用ip 什么是子网掩码？ 子网掩码，顾名思义，遮掩的意思，子网掩码就是把ip地址分为网络部分和主机部分，主机部分用二进制位用1标识，主机号部分用0标识。C类子网掩码一般是255.255.255.0 如果所需的ip比较多，比如学校这种环境，子网掩码可以设置成255.255.0.0 ,那么ip返回就是255的2次方-2，就是65023个。那么ip网络部分就是192.168,后面两部分是主机号。 网关是什么，比如两个A客户端192.168.1.2 和B客户端192.168.2.2 就是两个网络的设备，前提是他们的子网掩码都是255.255.255.0， 那么他们通信就需要A客户端发送给网关ip，有网关路由转发到B所在的网关，再转发到B客户端。 比如我的路由器ip是192.168.2.1， 我自己的ip是192.168.2.110， 默认网关也是192.168.2.1 12345netstat -rnDestination Gateway Genmask Flags MSS Window irtt Iface0.0.0.0 192.168.2.1 0.0.0.0 UG 0 0 0 ens330.0.0.0表示发给任何人的包，都发给192.168.2.1这个网关， Genmask写0.0.0.0是默认路由的网络掩码。","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[]},{"title":"python 导入模块文件以及相对导入和__init__文件作用","slug":"language/python/2__init__文件的作用","date":"2019-02-14T06:00:00.000Z","updated":"2019-05-19T14:18:38.608Z","comments":true,"path":"2019/02/14/language/python/2__init__文件的作用/","link":"","permalink":"http://wedvefv.github.io/2019/02/14/language/python/2__init__文件的作用/","excerpt":"","text":"python 导入模块文件的2中方式1234567891011121314import lib or from lib import *# 导入子目录中模块import tmp.lib3 or from tmp.lib3 import *# 导入上级目录import syssys.path.append('home/app/')import modimport xxxx 与import类似, 被导入的module仍然会执行且仅执行一次 from *** import 的实质 当以 “from *** import “ 方式导入module时, python会在当前module 的命名空间中新建相应的命名. 即, “from t2 import var1” 相当于: 12import t2var1= t2.var1 from package import item # 这种方式，item可以是包中的一个子模块或子包，也可以是包中定义的其他命名，像函数、类、变量。 import item.subitem.subsubitem # 这些子项必须是包，最后的子项是包或模块。但不能为函数、类或变量。否则出错：No module named *** __init__.py 的作用python import package都是根据每个module的name来实现的。比如说，有一个文件夹结构为： 123456package/ __init__.py subpackage1/ __init__.py moduleX.py moduleA.py 那么，如果（在这个package文件夹之外，比如package的同级文件夹下建立运行一个run.py）运行一个script，来导入moduleX模块，那么这个moduleX的name就是.package.subpackage1.moduleX，由于moduleX获得了前述名称，那么在moduleX.py内部就可以有relative import的语句，比如说：from .. import moduleA 而moduleX之所以能够获得的.package.subpackage1.moduleX的name attribute属性，前提是package被python解释器识别成了一个package来处理（比如在package的同级文件夹下的运行的run.py有import package.subpackage1.moduleX之类的语句）。可是，如果每一个被我直接run的python script都会被视作是top-level script。top-level script的name被自动设置成main。因此，如果我从package文件夹内部直接运行moduleA.py这个脚本，那么它的name就被置成了main，python也不会把它当作一个package，其中的relative import的语句自然就无法起作用了。 总之，运行脚本要在包目录的外层，包里面的模块之间才能用. 或则 ..等相对路径做导入操作。换句话，就是存在from .. import xxx 的文件不能直接python xxx.py操作，即使存在init.py, .也不会被认为是一个包。","categories":[{"name":"python","slug":"python","permalink":"http://wedvefv.github.io/categories/python/"}],"tags":[]},{"title":"python类的三种装饰器","slug":"language/python/1_三种装饰器","date":"2019-02-14T06:00:00.000Z","updated":"2019-05-19T14:18:38.608Z","comments":true,"path":"2019/02/14/language/python/1_三种装饰器/","link":"","permalink":"http://wedvefv.github.io/2019/02/14/language/python/1_三种装饰器/","excerpt":"","text":"property装饰器作用和原理 我们知道c++中有public,projected,private等修饰类私有属性的作用，这样就限定了某些属性只能读取，不能修改；有些能读也能需改。 设置C++类中的一个属性可以自定义方法get和set方法。 python中实现这种原理，就需要装饰器property，本身可修饰（变量x同名）的函数，让x拥有可读的属性（相当于get函数 @property进而又生成一个@x.setter装饰器，在修饰一下属性x同名的函数就让x拥有可写的属性（相当于set函数） property 装饰器1234567891011121314151617class Student(object): @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property def age(self): return 2014 - self._birth # birth 是一个可读可写的属性，age是只读属性。 # property装饰器本身可以把getter方法变成属性，同时生成一个@birth.setter装饰器，可以修饰birth变成一个可设置的属性。 # 但要注意这些额外函数的名字和 property 下的一样，例如这里的 birth,age。 一种古老的用法，使用内置函数property实现如下，和上面的方法一样。123456789101112131415161718192021222324252627282930313233343536class Animal(object): def __init__(self, name, age): self._name = name self._age = age self._color = 'Black' def get_name(self): return self._name def set_name(self, value): if isinstance(value, basestring): self._name = value else: self._name = 'No name' name = property(fget=get_name, fset=set_name, fdel=None, doc='name of an animal') def get_age(self): return self._age def set_age(self, value): if value &gt; 0 and value &lt; 100: self._age = value else: self._age = 0 # print 'invalid age value.' age = property(fget=get_age, fset=set_age, fdel=None, doc='name of an animal') a = Animal('black dog', 3)a.name = 'white dog'a.age = 3print 'Name:', a.nameprint Animal.name.__doc__print 'Age:', a.age","categories":[{"name":"python","slug":"python","permalink":"http://wedvefv.github.io/categories/python/"}],"tags":[]},{"title":"flask 第9章（大型程序目录结构）","slug":"language/python/9_大型程序结构","date":"2019-02-13T13:18:00.000Z","updated":"2019-05-19T14:30:17.032Z","comments":true,"path":"2019/02/13/language/python/9_大型程序结构/","link":"","permalink":"http://wedvefv.github.io/2019/02/13/language/python/9_大型程序结构/","excerpt":"","text":"1. 创建目录结构1234567891011121314151617181920212223242526272829mkdir myflask &amp; cd myflasktouch reuirments.txttouch config.py # 配置touch manger.py mkdir app # 一个应用一个app这样的目录touch app/__init__.py # 说明这是一个包touch app/emails.pytouch app/models.pymkdir app/templatesmkdir app/staticmkdir app/maintouch app/main/__init__.py #为了保存蓝本，整一个子包touch app/main/errors.pytouch app/main/forms.pytouch app/main/views.py# 迁移目录mkdir migrations# 单元测试目录mkdir testtouch test/__init__.pytouch test/test.py# venv 这个目录是虚拟环境目录，命令自动创建 2. 代码下载 代码太多就不站粘贴了,下面是下载地址，前面是每个章节是一个详细流程，这个结构中上下文这块还不是很懂，继续学习…1git clone https://github.com/wedvefv/my_flask_learn.git","categories":[{"name":"flask","slug":"flask","permalink":"http://wedvefv.github.io/categories/flask/"}],"tags":[]},{"title":"flask 第8章（邮件模块）","slug":"language/python/8_邮件模块","date":"2019-02-13T03:57:00.000Z","updated":"2019-05-19T14:30:17.032Z","comments":true,"path":"2019/02/13/language/python/8_邮件模块/","link":"","permalink":"http://wedvefv.github.io/2019/02/13/language/python/8_邮件模块/","excerpt":"","text":"安装模块1pip install flask-mail smtp配置 smtp 简单邮件传输协议,如果不配置，默认使用localhost主机，25端口，无需验证即可发送邮件 如果配置，这使用配置的服务器发送mail smtp 配置选项 配置 默认值 说明 MAIL_SERVER localhost 电子邮件服务器的主机名或ip地址 MAIL_PORT 25 电子邮件服务器的端口 MAIL_USE_TLS False 启用传输层安全 MAIL_USE_SSL False 启用安全套接层 MAIL_USERNAME None 邮件账户名 MAIL_PASSWORD None 邮件账户密码 整个hello.py文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#coding=utf=8import pymysqlpymysql.install_as_MySQLdb()import MySQLdb,os# 引入核心模块和模板加载模块from flask import Flask, render_template,session,redirect,url_for,flash# 引入bootstrap前端框架from flask_bootstrap import Bootstrap# 引入时间模块,实现了momment.jsfrom flask_moment import Moment# 引入manage模块，服务器启动参数控制from flask_script import Manager# 引入表单模块from flask_wtf import FlaskForm# 引入表单字段类from wtforms import StringField,SubmitField# 引入表单验证函数from wtforms.validators import Required# 导入数据库包from flask_sqlalchemy import SQLAlchemy# 导入数据迁移模块from flask_migrate import Migrate,MigrateCommand# 导入mail 模块from flask_mail import Mail,Message# 每个web表单都有一个继承自FlaskForm的类表示,所以先定义一个类class NameForm(FlaskForm): name = StringField(\"what is your name ?\",validators=[Required()]) # 字段对象可附加多个验证函数，所以是列表, Required确保非空 submit = SubmitField(\"Submit1\")app = Flask(__name__)# 生成加密令牌的密钥,再用令牌验证请求的表单数据真伪app.config['SECRET_KEY'] = 'this random string！'# 数据库配置app.config[\"SQLALCHEMY_DATABASE_URI\"] = \"mysql://appwriter:appwr@zxcv@127.0.0.1/flask1?charset=utf8\"app.config[\"SQLALCHEMY_COMMIT_ON_TEARDOWN\"] = True # 请求结束自动提交数据库变动app.config[\"SQLALCHEMY_TRACK_MODIFICATIONS\"] = True # 这行不能缺# MAIL 配置app.config[\"MAIL_SERVER\"] = 'smtp.qq.com' ## qq邮箱smtp服务器app.config['MAIL_PORT']= 25app.config['MAIL_USE_TLS'] = Falseapp.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME') #qq邮箱app.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD') #qq邮箱客户端登录授权码，相当于密码app.config['FLASK_MAIL_SUBJECT_PREFIX'] = '[Flasky]'app.config['FLASK_MAIL_SENDER'] = 'FLASK Admin&lt;%s&gt;' % os.environ.get('MAIL_USERNAME') #发送者app.config['FLASK_ADMIN'] = os.environ.get(\"FLASK_ADMIN\")print app.config['FLASK_ADMIN']#SQLALCHEMY_COMMIT_TEARDOWN = Truedb = SQLAlchemy(app) # 数据库实例 模型继承于db.model, 模型在python就是一个类，数据库中是一个表，类属性就是表字段bootstrap = Bootstrap(app)moment = Moment(app)manager = Manager(app)migrate = Migrate(app, db)manager.add_command('db', MigrateCommand)mail = Mail(app)# 定义模型class Role(db.Model): __tablename__ = 'roles' id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64),unique=True) users = db.relationship(\"User\", backref='role') def __repr__(self): return '&lt;Role %r&gt; ' % self.nameclass User(db.Model): __tablename__ = \"users\" id = db.Column(db.Integer,primary_key=True) username = db.Column(db.String(64),unique=True) role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) def __repr__(self): return '&lt;User %r&gt; ' % self.username@app.errorhandler(404)def page_not_found(e): return render_template('404.html'), 404@app.errorhandler(500)def internal_server_error(e): return render_template('500.html'), 500@app.route('/1', methods=['GET', 'POST'])def index1(): form = NameForm() if form.validate_on_submit(): old_name = session.get(\"name\") if old_name is not None and old_name != form.name.data: flash(\"your are changing your name .\") session[\"name\"] = form.name.data return redirect(url_for(\"index\")) # 一般endpoint就是视图函数名 return render_template(\"index.html\", form=form, name = session.get('name')) #return render_template(\"index.html\", form=form, name = None)@app.route(\"/\", methods=['GET','POST'])def index(): form = NameForm() if form.validate_on_submit(): user = User.query.filter_by(username=form.name.data).first() if user is None: user = User(username=form.name.data) db.session.add(user) session['known'] = False else: session['known'] = True session['name'] = form.name.data form.name.data = '' return redirect(url_for(\"index\")) return render_template(\"index.html\", form = form, name = session.get(\"name\"), known=session.get('known',False) )def send_email(to, subject, template, **kwargs): msg = Message(app.config['FLASK_MAIL_SUBJECT_PREFIX'] + subject, sender=app.config['FLASK_MAIL_SENDER'], recipients=[to]) #msg.body = render_template(template + '.txt', **kwargs) msg.html = render_template(template + '.html',**kwargs) mail.send(msg) @app.route(\"/mail\", methods=['GET','POST'])def index2(): print 90 form = NameForm() if form.validate_on_submit(): user = User.query.filter_by(username=form.name.data).first() # 如果数据库没有这个name，说明是新用户，就给管理员发封邮件。 #print \"2222\", user if user is None: user = User(username=form.name.data) db.session.add(user) session['known'] = False if app.config['FLASK_ADMIN']: #print \"123\",app.config['FLASK_ADMIN'] send_email(app.config['FLASK_ADMIN'], 'New User', 'mail/new_user',user=user) else: session['known'] = True session['name'] = form.name.data form.name.data = '' return redirect(url_for('index2')) return render_template('index.html',form=form,name=session.get('name'),known=session.get('known',False))if __name__ == \"__main__\": manager.run() 邮件模板1234mkdir template/mailtouch template/mail/new_user.html写入邮件模板,用户提交用户名时，向ADMIN发送一封邮件。User &#123;&#123; user.username &#125;&#125; has joined. 需要配置的环境变量1234vim /etc/profileexport MAIL_USERNAME='' # 比如qq邮箱账号export MAIL_PASSWORD='' # 如果是qq邮箱，这里是qq邮箱的客户端授权码，需要短信验证生成export FLASK_ADMIN='' # 这封邮件的接受者","categories":[{"name":"flask","slug":"flask","permalink":"http://wedvefv.github.io/categories/flask/"}],"tags":[]},{"title":"flask 第7章（数据迁移模块）","slug":"language/python/7_数据迁移","date":"2019-02-13T03:41:00.000Z","updated":"2019-05-19T14:30:17.032Z","comments":true,"path":"2019/02/13/language/python/7_数据迁移/","link":"","permalink":"http://wedvefv.github.io/2019/02/13/language/python/7_数据迁移/","excerpt":"","text":"安装模块1pip install flask-migrate 配置模块12345# 导入模块类from flask_migrate import Migrate,MigrateCommand# ...migrate = Migrate(app,db)manger.add_command('db', MigrateCommand) 执行顺序1. 初始化迁移仓库12python hello.py db init# 会创建migrations 文件夹 2. 创建迁移脚本模板12python hello.py db migrate -m \"migrate initial\"# version文件夹会生成一个py文件里面有2个函数，升级数据库函数upgrade，降级数据库函数downgrade，需要用户自己重写所需操作 3. 升级更新数据库1234python hello.py db upgrade # 执行该命令会自动执行version目录下的py脚本中的upgrade函数，前提是数据库alembic_version表中没有该版本的升级记录。# 对于第一个迁移，和db.create_all()方法一样，后续版本升级，upgrade命令会把改动应用到数据库中。","categories":[{"name":"flask","slug":"flask","permalink":"http://wedvefv.github.io/categories/flask/"}],"tags":[]},{"title":"linux虚拟机配置静态ip","slug":"linux/linux虚拟机配置静态ip","date":"2019-02-12T06:00:00.000Z","updated":"2019-03-02T10:16:37.986Z","comments":true,"path":"2019/02/12/linux/linux虚拟机配置静态ip/","link":"","permalink":"http://wedvefv.github.io/2019/02/12/linux/linux虚拟机配置静态ip/","excerpt":"","text":"1. mac上的虚拟机使用（自动模式）就是桥接模式。 2. 查看自己的网卡名 ifconfig 命令 123456789101112131415161718[root@localhost ~]# ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.2.132 netmask 255.255.255.0 broadcast 192.168.2.255 inet6 fe80::315:b3ba:674b:3fdc prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:14:d2:38 txqueuelen 1000 (Ethernet) RX packets 56630 bytes 20928797 (19.9 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 24078 bytes 2636531 (2.5 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1 (Local Loopback) RX packets 2517 bytes 223561 (218.3 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 2517 bytes 223561 (218.3 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 我的网卡就是ens33,下面lo是本地回环地址，ip是127.0.0.1 修改网卡配置文件vim /etc/sysconfig/network-scripts/ifcfg-ens33 1234567891011121314151617181920212223242526272829303132333435363738 1 TYPE=Ethernet 2 PROXY_METHOD=none 3 BROWSER_ONLY=no 4 #BOOTPROTO=dhcp 5 DEFROUTE=yes 6 IPV4_FAILURE_FATAL=no 7 IPV6INIT=yes 8 IPV6_AUTOCONF=yes 9 IPV6_DEFROUTE=yes 10 IPV6_FAILURE_FATAL=no 11 IPV6_ADDR_GEN_MODE=stable-privacy 12 NAME=ens33 13 UUID=5e4d74e0-4fd2-48b9-8856-a206acc5b6ea 14 DEVICE=ens33 15 #ONBOOT=yes 16 17 # 下面是新增的部分，上面的BOOTPROTO和ONBOOT注释掉。 18 # static config 19 NM_CONTROLLED=no # use config file not network manager. 20 BOOTPROTO=static 21 ONBOOT=yes 22 IPADDR=192.168.2.132 23 NETMASK=255.255.255.0 24 GATEWAY=192.168.2.1 25 ``` ## 设置DNSvim /etc/sysconfig/network```shell # 这个文件主要是设置HOSTNAME,设置是否启动网络，需要reboot，如果修改网关，重启service就行了 写入： DNS1=8.8.8.8 DNS2=114.114.114.114 GATEWAY=192.168.2.1 # 一般是路由器的ip，我家两个路由器，一个是192.168.1.1，一个是192.168.2.1。 重启服务1service network restart","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[]},{"title":"flask 第3章(bootstrap扩展模板)","slug":"language/python/3_模板的bootstrap扩展","date":"2019-01-28T14:22:00.000Z","updated":"2019-05-19T14:30:17.031Z","comments":true,"path":"2019/01/28/language/python/3_模板的bootstrap扩展/","link":"","permalink":"http://wedvefv.github.io/2019/01/28/language/python/3_模板的bootstrap扩展/","excerpt":"","text":"模板的bootstrap扩展 安装扩展包 pip install flask-bootstrap 如法炮制，从flask.ext中导入Bootstrap 包含app对象生成新的对象实例，即可使用bootstrap的特性。 如果使用bootstrap那么需要先用bootstrap包含app，在用manager包含app。 自定一个base.html(继承自bootstrap的base.html) 1234567891011121314151617181920212223242526272829303132333435363738&#123;% extends \"bootstrap/base.html\" %&#125;&#123;% block title %&#125; &#123;% endblock %&#125;&#123;% block navbar %&#125; &lt;div class=\"navbar navbar-inverse\" role=\"navigation\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle\" data-toogle=\"collapse\" data-target=\".narvar-collapse\"&gt; &lt;span class=\"sr-only\"&gt; Toggle navigation &lt;/span&gt; &lt;span class=\"icon-bar\"&gt; &lt;/span&gt; &lt;span class=\"icon-bar\"&gt; &lt;/span&gt; &lt;span class=\"icon-bar\"&gt; &lt;/span&gt; &lt;span class=\"icon-bar\"&gt; &lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"/\"&gt;Home/a&gt; &lt;/div&gt; &lt;div class=\"navbar-collapse collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt; &lt;a hre=\"/\"&gt; Home &lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125;&lt;% block comment %&gt; &lt;div class=\"container\"&gt; &#123;% block page_comment %&#125; &#123;% endblock %&#125; &lt;/div&gt;&lt;% endblock %&gt; 自定义基类模板1234567891011# 404.html&#123;% extends \"base.html\" %&#125;&#123;% block title %&#125; flask-pagenot found &#123;% endblock %&#125;&#123;% block page_comment %&#125;&lt;div class=\"page-header\"&gt; &lt;h1&gt; Not Found. &lt;/h1&gt;&lt;/div&gt;&#123;%endblock%&#125; 整个代码文件12345678910111213141516171819202122232425from flask import Flask, render_templatefrom flask_script import Managerfrom flask_bootstrap import Bootstrapapp = Flask(__name__)bootstrap = Bootstrap(app)manager = Manager(app)@app.route('/')def index(): return render_template(\"index.html\")@app.route('/user/&lt;name&gt;')def user(name): return render_template(\"user.html\",name=name)@app.errorhandler(404)def page_not_found(e): return render_template(\"404.html\"), 404 if __name__ == '__main__': manager.run() 运行命令 ： python hello.py runserver –host 0.0.0.0 –d 链接a标签常用的href 可以使用url_for 函数生成url_for(“index”) –&gt; / url_for(“index”,_external=True) –&gt; 绝对路径 url_for(“index”, page=2 ) 返回？/page=2 静态文件生成链接url_for(‘static’, filename=’css/styles.css’, _external=True)返回 http://localhost:5000/statics/css/style.css flask-moment组件本地化时间和日期 pip install flask-moment 123456789&#123;% extends \"base.html\" %&#125;&#123;% block page_content %&#125;&lt;h1&gt; hello world!&lt;/h1&gt;&lt;p&gt; local date and time is &#123;&#123; moment(current_time).format('LLL')&#125;&#125;. &lt;/p&gt;&lt;p&gt; that was &#123;&#123; moment(current_time).fromNow(refresh=True) &#125;&#125;. &lt;/p&gt;&#123;% endblock %&#125;","categories":[{"name":"flask","slug":"flask","permalink":"http://wedvefv.github.io/categories/flask/"}],"tags":[]},{"title":"flask 第5章(数据库操作)","slug":"language/python/5_数据库1","date":"2019-01-28T14:22:00.000Z","updated":"2019-05-19T14:30:17.031Z","comments":true,"path":"2019/01/28/language/python/5_数据库1/","link":"","permalink":"http://wedvefv.github.io/2019/01/28/language/python/5_数据库1/","excerpt":"","text":"数据库操作1. 安装需要的包 pip install flask-sqlalchemy hello.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#coding=utf=8import pymysqlpymysql.install_as_MySQLdb()import MySQLdb # MySQLdb 只支持python2 ,我这limitlinux转不上，只能装pymysql代替，但是需要上面2行代码# 引入核心模块和模板加载模块from flask import Flask, render_template,session,redirect,url_for,flash# 引入bootstrap前端框架from flask_bootstrap import Bootstrap# 引入时间模块,实现了momment.jsfrom flask_moment import Moment# 引入manage模块，服务器启动参数控制from flask_script import Manager# 引入表单模块from flask_wtf import FlaskForm# 引入表单字段类from wtforms import StringField,SubmitField# 引入表单验证函数from wtforms.validators import Required#导入数据库包from flask_sqlalchemy import SQLAlchemy# 每个web表单都有一个继承自FlaskForm的类表示,所以先定义一个类class NameForm(FlaskForm): name = StringField(\"what is your name ?\",validators=[Required()]) # 字段对象可附加多个验证函数，所以是列表, Required确保非空 submit = SubmitField(\"Submit1\")app = Flask(__name__)# 生成加密令牌的密钥,再用令牌验证请求的表单数据真伪app.config['SECRET_KEY'] = 'this random string！'# 数据库配置app.config[\"SQLALCHEMY_DATABASE_URI\"] = \"mysql://appwriter:appwr@zxcv@192.168.43.186/flask?charset=utf8\"app.config[\"SQLALCHEMY_COMMIT_ON_TEARDOWN\"] = True # 请求结束自动提交数据库变动app.config[\"SQLALCHEMY_TRACK_MODIFICATIONS\"] = True # 这行不能缺#SQLALCHEMY_COMMIT_TEARDOWN = Truedb = SQLAlchemy(app) # 数据库实例 模型继承于db.model, 模型在python就是一个类，数据库中是一个表，类属性就是表字段bootstrap = Bootstrap(app)moment = Moment(app)manager = Manager(app)# 定义模型class Role(db.Model): __tablename__ = 'roles' id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64),unique=True) users = db.relationship(\"User\", backref='role') def __repr__(self): return '&lt;Role %r&gt; ' % self.nameclass User(db.Model): __tablename__ = \"users\" id = db.Column(db.Integer,primary_key=True) username = db.Column(db.String(64),unique=True) role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) def __repr__(self): return '&lt;User %r&gt; ' % self.username@app.errorhandler(404)def page_not_found(e): return render_template('404.html'), 404@app.errorhandler(500)def internal_server_error(e): return render_template('500.html'), 500@app.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_submit(): old_name = session.get(\"name\") if old_name is not None and old_name != form.name.data: flash(\"your are changing your name .\") session[\"name\"] = form.name.data return redirect(url_for(\"index\")) # 一般endpoint就是视图函数名 return render_template(\"index.html\", form=form, name = session.get('name')) #return render_template(\"index.html\", form=form, name = None)if __name__ == \"__main__\": manager.run() 2. SQLAlchemy 常用的列类型 类型名 python类型 说明 Integer int 普通整数一般32位 Smallinteger int 一般16位的整数 BigInteger int 不限制精度的整数 Float float 浮点数 Numeric decimal.Decimal 定点数，小数 String str 字符串 Text str 较长的字符串，做了优化，或不限制长度 Unicode unicode 变长unicode字符串，对不限长度的字符串做了优化 Boolean bool 布尔值 Date datetime.date 日期 Time datetime.time 时间 DateTime datetime.datetime 日期和时间 Interval datetime.timedelta 时间间隔 Enum str 一组字符串 PickleType 任何python对象 石洞使用Pickle序列化 LargeBinary str 二进制文件 3. SQLAlchemy常用的列选项 选项名 说明 primary_key 表主键 unique 设为true，表示这列不允许重复 index 设为True,表示这列建立索引 nullalbe 设为True,表示这列允许位空值NULL，fasle表示不允许为空 default 为这列默认值 最复杂的就是多对多的关系，需要第三张表，使用db.relationship()设置。 4. 数据库操作 python shell中操作 123python hello.py shellfrom hello import dbdb.create_all()","categories":[{"name":"flask","slug":"flask","permalink":"http://wedvefv.github.io/categories/flask/"}],"tags":[]},{"title":"flask 第4章(表单)","slug":"language/python/4_web表单","date":"2019-01-28T14:22:00.000Z","updated":"2019-05-19T14:30:17.031Z","comments":true,"path":"2019/01/28/language/python/4_web表单/","link":"","permalink":"http://wedvefv.github.io/2019/01/28/language/python/4_web表单/","excerpt":"","text":"表单的处理1pip install flask-wtf 1. 跨站请求伪造保护XSRF和XSS XSRF 跨站请求伪造** 利用用户已经登陆了的网站上执行非法操作，利用了网站对已登录用户的信任。 XSS 跨站脚本攻击** 利用用户对制定网站的信任，执行一些非法操作。 为了防止XSRF攻击，所以有了 SECRET_KEY配置项。 2. 主文件hello.py 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#coding=utf=8# 引入核心模块和模板加载模块from flask import Flask, render_template# 引入bootstrap前端框架from flask_bootstrap import Bootstrap# 引入时间模块,实现了momment.jsfrom flask_moment import Moment# 引入manage模块，服务器启动参数控制from flask_script import Manager# 引入表单模块from flask_wtf import FlaskForm# 引入表单字段类from wtforms import StringField,SubmitField# 引入表单验证函数from wtforms.validators import Required# 每个web表单都有一个继承自FlaskForm的类表示,所以先定义一个类class NameForm(FlaskForm): name = StringField(\"what is your name ?\",validators=[Required()]) # 字段对象可附加多个验证函数，所以是列表, Required确保非空 submit = SubmitField(\"Submit1\")app = Flask(__name__)# 生成加密令牌的密钥,再用令牌验证请求的表单数据真伪,app.config['SECRET_KEY'] = 'this random string！'bootstrap = Bootstrap(app)moment = Moment(app)manager = Manager(app)@app.errorhandler(404)def page_not_found(e): return render_template('404.html'), 404@app.errorhandler(500)def internal_server_error(e): return render_template('500.html'), 500@app.route('/', methods=['GET', 'POST']) #如果不附加post方法，会get提交表单，信息就暴漏在浏览器地址栏中了。def index(): name = None form = NameForm() if form.validate_on_submit(): name = form.name.data form.name.data = '' return render_template(\"index.html\",form = form, name = name)if __name__ == \"__main__\": manager.run() 第一次请求页面是get方式，validate_on_submit()函数返回false , 表单对象和name=None传入模板，用户看到就是表单的样子 用户输入name提交时，是post请求，validate_on_submit()返回true，表单对象传入name会被清空，name参数也传入，显示在页面。hello， nama！ 3.模板文件index.html123456789101112&#123;% extends \"base.html\" %&#125;&#123;% import \"bootstrap/wtf.html\" as wtf %&#125;&#123;% block title %&#125;Flasky&#123;% endblock %&#125;&#123;% block page_content %&#125;&lt;div class=\"page-header\"&gt; &lt;h1&gt;Hello, &#123;% if name %&#125;&#123;&#123; name &#125;&#125;&#123;% else %&#125;Stranger&#123;% endif %&#125;!&lt;/h1&gt;&lt;/div&gt;&#123;&#123; wtf.quick_form(form) &#125;&#125;&#123;% endblock %&#125; 12&#123;% import \"bootstrap\\/wtf.html\" as wtf %&#125; 引入wtf模板，&#123;&#123; wtf.quick_form(form) &#125;&#125;填充表单数据 4. wtdforms 支持的表单字段类型 字段类型 说明 StringField 文本字段 TextAreaField 多行文本 PasswordField 密码文本字段 HiddenField 隐藏文本字段 DateField 文本字段，值为datetime.date格式 IntrgerField 文本字段，为整数 DecimalField 文本字段，值为小数 FloatField 文本字段，值为浮点数 BooleanField 复选框，值为flase和true RadioField 一组单选框 SelectField 下拉列表 SelectMultipleField 下拉列表可选多个值 FileField 文件上传字段 SubmitField 表单提交按钮 FormField 把表单作为一个字段嵌入另一个表单 FieldList 一组指定类型的字段 5. wtfforms验证函数 验证函数 说明 Email 验证mail地址 EqualTo 比较2个字段的值，常用语密码输入两次对比 IPAddress 验证ipv4网络地址 Length 验证输入字符串的长度 NumberRange 验证输入的值在数字范围内 Optional 无输入值时跳过其他验证函数 Required 确保字段有值 Regexp 使用正则表达式验证输入值 URL 验证url AnyOf 确保输入值在可选列表 NoneOf 确保输入值不在可选列表 6. 重定向和用户会话 目前hello.py 刷新会出现一警告，这个警告是因为最后一次提交是post请求导致的，所以使用url重定向让最后一次请求变为get请求,那么问题是之前的post参数怎么获取呢，不然网页无法渲染，这就需要session字典形式存储，get请求时从session中获取所需字段。 12345678910from flask import session,url_for@app.route(\"/\")def index(): form = NameForm() if form.validate_on_submit(): session[\"name\"] = form.name.data return redirect(url_for(\"index\")) # 一般endpoint就是视图函数名 return render_template(\"index.html\", form=form, name = session.get('name')) #session.get 函数找不到name字段，返回None，网页有默认提示。 7. flash消息(闪现,闪烁) 主要用于警告，消息提醒，比如用户输入了错误的用户名和密码，需要一个提醒，就可以使用flash功能。 只调用flash函数是显示不出消息的，它主要是把消息push方式存入一个地方，然后程序使用模板渲染时可以pop方式获取到，所以flash消息就像队列，先进先出，只会显示一次。 123456789101112form flask import flash@app route(\"/\", methods=['GET','POST'])def index(): form = NameForm() if form.validate_on_submit(): old_name = session.get(\"name\") if old_name is not None and old_name != form.name.data: flash(\"looks like you have change your name.\") session['name'] = form.name.data return redirect(url_for(\"index\")) return render_template(\"index.html\", form = form, name = sesson.get(\"name\")) 在base.html 模板中渲染循环取出消息 12345678910111213141516&#123;# content 部分添加for循环#&#125;&#123;% block content %&#125; &lt;div class=\"container\"&gt; &#123;# 增加一个 for循环#&#125; &#123;% for message in get_flashed_messages() %&#125; &lt;div class=\"alert alert-warning\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\"&gt; $times; &lt;/button&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% block page_content %&#125; &#123;% endblock %&#125; &lt;/div&gt;&#123;% endblock %&#125;","categories":[{"name":"flask","slug":"flask","permalink":"http://wedvefv.github.io/categories/flask/"}],"tags":[]},{"title":"flask 第6章(数据库操作2)","slug":"language/python/6_数据库2","date":"2019-01-28T14:22:00.000Z","updated":"2019-05-19T14:30:17.032Z","comments":true,"path":"2019/01/28/language/python/6_数据库2/","link":"","permalink":"http://wedvefv.github.io/2019/01/28/language/python/6_数据库2/","excerpt":"","text":"创建数据写入数据1234567891011121314151617181920212223242526&gt;&gt;&gt; db.create_all()&gt;&gt;&gt; from hello import Role,User&gt;&gt;&gt; admin_role=Role(name=\"Admin\")&gt;&gt;&gt; mod_role = Role(name=\"Moderator\")&gt;&gt;&gt; user_role=Role(name=\"User\")&gt;&gt;&gt; user_john=User(username=\"john\",role=admin_role)&gt;&gt;&gt; user_susan=User(username=\"susan\",role=user_role)&gt;&gt;&gt; user_david = Ueser(username=\"david\",role=user_role)这个时候还没有写入数据库，比如打印&gt;&gt;&gt; print(admin_role.id)None然后可以这样将之前的对象加入到回话中即可&gt;&gt;&gt; db.session.add(mod_role)\u0000\u0000\u0000&gt;&gt;&gt; db.session.add(user_role)&gt;&gt;&gt; db.session.add(user_john)&gt;&gt;&gt; db.session.add(user_david)&gt;&gt;&gt; db.session.commit() # 没有这一句是不行的。或者可以全部添加&gt;&gt;&gt; db.session.add([admin_role,mod_role,...])再次查看admin_role.id就有值了&gt;&gt;&gt; print admin_role.id1 修改一行12345678# 比如修改admin_role的name为new_admin&gt;&gt;&gt; admin_role.name = \"new_admin\"&gt;&gt;&gt; db.session.add(admin_role)&gt;&gt;&gt; db.session.commit()&gt;&gt;&gt; print admin_role.namenew_admin&gt;&gt;&gt; 删除一行12db.session.delete(mod_role)db.session.commit() 查询行1234567查询2个表所有字段&gt;&gt;&gt; Role.query.all()[&lt;Role u'Moderator'&gt; , &lt;Role u'new_admin'&gt; , &lt;Role u'User'&gt; ]&gt;&gt;&gt; User.query.all()[&lt;User u'john'&gt; , &lt;User u'susan'&gt; , &lt;User u'david'&gt; ]&gt;&gt;&gt; 常用的sql过滤器|过滤器|说明|||-||filter|把过滤器添加到查询上，返回一个新查询||filter_by|把等值过滤添加到原查询上，返回一个新查询||limit|指定原查询的数量限制||offset|便宜原查询的结果，返回一个新查询||order_by|根据指定条件对原查询进行排序，返回一个新查询||group_by|执行分组条件| 过滤器之后可以跟执行函数 方法 说明 all 以列表的形式返回所有结果 first 返回查询的第一个结果，没有返回None first_or_404 返回第一个查询结果，否则终止请求，返回404 get 返回指定主键对应的列，否则返回None get_or_404 返回指定主键对应的行，否则返回404 count 返回结果数量 paginate 返回一个paginate对象，包含指定范围的结果","categories":[{"name":"flask","slug":"flask","permalink":"http://wedvefv.github.io/categories/flask/"}],"tags":[]},{"title":"flask 第1章(基本结构和概念)","slug":"language/python/1基本结构","date":"2019-01-28T14:22:00.000Z","updated":"2019-05-19T14:30:17.031Z","comments":true,"path":"2019/01/28/language/python/1基本结构/","link":"","permalink":"http://wedvefv.github.io/2019/01/28/language/python/1基本结构/","excerpt":"","text":"开始和程序基本结构1.首先安装虚拟环境包和git工具 sudo apt-get install python-virtualenv sudo apt-get install git 2.创建一个目录 mkdir flask_learn cd flask_learn 3.下载实例代码 git clone http://github.com/miguelgrinberg/flasky.git cd flask 建立一个虚拟环境 virtualenv venv 激活虚拟环境 source venv/bin/activate 取消激活分区 deactivate 虚拟环境下安装pip pip install flask 切换分支 git checkout 2a 12345678910from flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return '&lt;h1&gt;Hello World!&lt;/h1&gt;'if __name__ == \"__main__\": app.run(debug=True) 执行 python hello.py 浏览器输入http://127.0.0.1:5000/ 就可以看到helloword了。 但是这样会出现一个问题。你在linux虚拟机里面执行的代码。在window上浏览器看就不行，需要设置 如下改动 app.run(debug=True，host=”0.0.0.0”)或者使用manage模块扩展传参数，后面会提到。 4. flask程序有四个上下文 curent_app 程序上下文， 当前激活的程序实例 g 程序上下文 处理请求的临时存储对象，每次请求都会重设这个变量。 request 请求上下文 请求对象，封装了每次http请求的内容 sesion 请求上下文 用户会话， 用于存储之间需要记住的值的词典。 这是个变量每次请求 都是独立属于这一次请求的，或者说是属于同一个线程内全局可见。 5. 请求调度 这个主要是 url和处理函数的映射关系，即视图。 通过app.url_map 可以看到映射关系。 生成映射的方法2中，1 app.route修饰器 2，app.add_url_rule() 6. 请求钩子 主要是为了每个请求开始可能都需要认证，数据库连接等重复操作的代码复。 通过钩子装饰器，注册函数，在到达视图函数前运行这些函数。 有四种个钩子 brefore_first_request,brefore_request,after_request,teardown_request after_request 有没做处理的异常抛出时，是不运行的。teardown_request 即使有没处理的异常抛出，也会运行。 7. 响应 flask 默认返回200 状态吗 可以返回其他状态吗 1234return \"hello word!\", 400或者return \"hello world!\", 500, &#123;\"ua\":10&#125;返回的是一个元组，第二个是状态吗，第三个是header，字典形式。 还可以使用make_response(“hello world!”, 500, {“ua”:10})生成一个对象，以便调用函数设置cookie等其他值。 320重定向，使用redirect(“www.baidu.com&quot;)函数。 特殊响应，比如404 可以使用abort(404)函数，这个直接就吧控制权交给web服务器了，不会再调用其它函数。 8. flask扩展 pip install flask-script 用manager吧app对象包住，这样就可以使用manager扩展了。 1234567891011121314151617181920from flask import Flaskfrom flask_script import Managerapp = Flask(__name__)manager = Manager(app)@app.route('/')def index(): return '&lt;h1&gt;Hello World!&lt;/h1&gt;'@app.route('/user/&lt;name&gt;')def user(name): return '&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % nameif __name__ == '__main__': manager.run() 启动服务： python hello.py runserver –host 0.0.0.0 9 模板的继承 类似于python中的类的继承 首先需要一个基类模板base.html 然后把对应的可修改的块用 格式包含即可。 123456789&lt;html&gt; &lt;haed&gt; &#123;% block head%&#125; &#123;%endblock%&#125; &#123;% block title%&#125; &#123;%endblock%&#125; &lt;/head&gt; &lt;body&gt; &#123;%block body%&#125; &#123;%endblock%&#125; &lt;/body&gt;&lt;/html&gt; 在子类模板中使用基类模板 12345678910111213&#123;%extends \"base.html\"% &#125;&#123;%block title%&#125; 这是index标题 &#123;%endblock%&#125;&#123;%block head%&#125; &#123;&#123;super()&#125;&#125; #基类head部分原本的内容用supper获取 &lt;style&gt; &lt;/style&gt;&#123;%endblock%&#125;&#123;%block body%&#125; &lt;h1&gt; hello world &lt;/h1&gt;&#123;%endblock%&#125;","categories":[{"name":"flask","slug":"flask","permalink":"http://wedvefv.github.io/categories/flask/"}],"tags":[]},{"title":"flask 第2章(模板)","slug":"language/python/2_模板","date":"2019-01-28T14:22:00.000Z","updated":"2019-05-19T14:30:17.031Z","comments":true,"path":"2019/01/28/language/python/2_模板/","link":"","permalink":"http://wedvefv.github.io/2019/01/28/language/python/2_模板/","excerpt":"","text":"模板1. jinja2模板引擎 创建模板目录 mkdir templates cd templates vim index.html 输入 &lt;h1> hello world! &lt;/h1> vim user.html 输入 &lt;h1> hello &lt;/h1> 2. 变量普通变量 占位符变量可以是python中的类型1234&#123;&#123; mydict['key'] &#125;&#125;&#123;&#123; mylist[3] &#125;&#125;&#123;&#123; mylist[value] &#125;&#125;&#123;&#123; obje.func() &#125;&#125; 过滤器 hello 把name转成搜字符大写。 过滤器名字 说明 safe 渲染时不转义 capitalize 首字母大写 lower 转成小写 upper 转成大写 title 每个单词首字母转大写 trim 去掉首尾空格 striptags 渲染前把其中的html标签都删除掉 safe 常用在现实html代码本身，不然标签会被引擎默认转义(这样也是为了安全考虑)。 不要再不可信的值上使用safe过滤器，比如表单输入。 3. 控制结构if结构12345&#123; % if user %&#125; hello &#123;&#123;user&#125;&#125;&#123;% else %&#125; hello stranger&#123;% endif %&#125; for循环结构12345&lt;ul&gt;&#123; % for x in list %&#125; &lt;li&gt;&#123;&#123; x &#125;&#125;&lt;/li&gt;&#123; %endfor% &#125;&lt;/ul&gt; 宏。 类似python的函数1234567891011121314151617181920212223* 定义宏 &#123;% macro render_comment(x) %&#125; &lt;li&gt;&#123;&#123; x &#125;&#125;&lt;/li&gt; &#123;% endmacro%&#125;* 使用&lt;ul&gt; &#123;% for x in list %&gt; &#123;&#123; render_comment(x) &#125;&#125; &#123; %endfor%&#125; &lt;/ul&gt;* 可以将宏放入单独的文件，一边重复使用，使用时导入即可。&#123; % import 'macros.html' as macros % &#125;&lt;ul&gt; &#123;% for x in list %&gt; &#123;&#123; macros.render_comment(x) &#125;&#125; &#123; %endfor%&#125;&lt;/ul&gt;* 需要重复使用的模板也可单独放一个文件中用到的地方 &#123;% include 'common.html'%&#125; 包含即可。","categories":[{"name":"flask","slug":"flask","permalink":"http://wedvefv.github.io/categories/flask/"}],"tags":[]},{"title":"最小化安装centos7配置问题","slug":"linux/2018-10-05_linux","date":"2018-10-05T02:34:58.000Z","updated":"2019-03-02T10:16:37.992Z","comments":true,"path":"2018/10/05/linux/2018-10-05_linux/","link":"","permalink":"http://wedvefv.github.io/2018/10/05/linux/2018-10-05_linux/","excerpt":"","text":"最小化安装启用网卡1234vi /etc/sysconfig/network-scripts/ifcfg-[网卡]修改 ONBOOT=yesservice network restart ip 命令替代了config, 常见用法123456789101112131415161718192021222324252627ip link show # 显示网络接口信息ip link set eth0 upi # 开启网卡ip link set eth0 down # 关闭网卡ip link set eth0 promisc on # 开启网卡的混合模式ip link set eth0 promisc offi # 关闭网卡的混个模式ip link set eth0 txqueuelen 1200 # 设置网卡队列长度ip link set eth0 mtu 1400 # 设置网卡最大传输单元ip addr show # 显示网卡IP信息ip addr add 192.168.0.1/24 dev eth0 # 设置eth0网卡IP地址192.168.0.1ip addr del 192.168.0.1/24 dev eth0 # 删除eth0网卡IP地址ip route list # 查看路由信息ip route add 192.168.4.0/24 via 192.168.0.254 dev eth0 # 设置192.168.4.0网段的网关为192.168.0.254,数据走eth0接口ip route add default via 192.168.0.254 dev eth0 # 设置默认网关为192.168.0.254 英文环境的mac远程centos虚拟机乱码原因分析 mac默认是 12LANG=en_US.utf-8 // 设置区域语言，比如提示信息，日期等等LC_ALL=en_US.utf-8 远程虚拟机最小化安装 echo $LANG linux 配置问价加载顺序是12默认登陆方式，/etc/enviroment-&gt;/etc/profile --&gt;$HOME/.profile --&gt;$HOME/.env /etc/profile是登陆后读取的，如果文件显示乱码，可以在/etc/profile中配置 12vim /etc/profileexport LC_ALL=zh_CN.utf-8 如果ssh远程出现如下问题 “-bash: 警告:setlocale: LC_CTYPE: 无法改变区域选项 (UTF-8): 没有那个文件或目录” 是加载/etc/enviroment文件,找LANG变量 123vim /etc/environmentLANG=zh_CN.utf-8如果/etc/environment 中没有设置该变量LANG，依然会报错，不能在profile中设置","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://wedvefv.github.io/tags/hexo/"}]},{"title":"centos6.4 安装python mysql扩展","slug":"linux/centos6.4install-mysql-python","date":"2018-06-30T02:15:00.000Z","updated":"2019-05-19T14:30:17.032Z","comments":true,"path":"2018/06/30/linux/centos6.4install-mysql-python/","link":"","permalink":"http://wedvefv.github.io/2018/06/30/linux/centos6.4install-mysql-python/","excerpt":"","text":"要想使python可以操作mysql 就需要MySQL-python驱动，它是python 操作mysql必不可少的模块。 下载地址：https://pypi.python.org/pypi/MySQL-python/ 下载MySQL-python-1.2.5.zip 文件之后直接解压。进入MySQL-python-1.2.5目录: python setup.py install 报错： [root@centos7 MySQL-python-1.2.4]# python setup.py install sh: mysql_config: command not found Traceback (most recent call last): File “setup.py”, line 18, in metadata, options = get_config() File “/root/MySQL-python-1.2.4/setup_posix.py”, line 43, in get_config libs = mysql_config(&quot;libs_r&quot;) File “/root/MySQL-python-1.2.4/setup_posix.py”, line 25, in mysql_config raise EnvironmentError(&quot;%s not found&quot; % (mysql_config.path,)) EnvironmentError: mysql_config not found 网上查了一下需安装mysql-devel #yum -y install mysql-devel 安装成功后 python setup.py install安装成功。","categories":[{"name":"c","slug":"c","permalink":"http://wedvefv.github.io/categories/c/"}],"tags":[]},{"title":"centos6.4 升级python到2.7","slug":"linux/centos6.4升级python","date":"2018-06-30T02:15:00.000Z","updated":"2019-03-02T10:16:37.993Z","comments":true,"path":"2018/06/30/linux/centos6.4升级python/","link":"","permalink":"http://wedvefv.github.io/2018/06/30/linux/centos6.4升级python/","excerpt":"","text":"1. download source1wget https://www.python.org/ftp/python/2.7.12/Python-2.7.12.tgz 2. compire and install1234tar zxvf Python-2.7.12.tgzcd Python-2.7.12./configure --prefix=/usr/local/python27 &amp;&amp; make &amp;&amp; make install &amp;&amp; echo $?如果以上输出为0，说明没有报错，安装正常 3. add path and backup the python2.61234567移除以前的版本mv /usr/bin/python /usr/bin/python26创建软连接ln -s /usr/local/python27/bin/python /usr/bin/python查看版本是否升级成功python -VPython 2.7.12 4. modify yum1234如果不修改此项，会导致yum无法使用vim /usr/bin/yum修改第一行即可，将环境变量指向以前的python版本#!/usr/bin/python26 5. reinstall pip12345678910111213141516171819202122232425262728291.安装pip之前首先需要安装setuptools下载链接https://pypi.python.org/pypi/setuptools下载地址wget https://pypi.python.org/packages/ff/d4/209f4939c49e31f5524fa0027bf1c8ec3107abaf7c61fdaad704a648c281/setuptools-21.0.0.tar.gz#md5=81964fdb89534118707742e6d1a1ddb4 --no-check-certificate解压tar zxvf setuptools-21.0.0.tar.gz安装cd setuptools-21.0.0python setup.py install2.安装pip下载链接https://pypi.python.org/pypi/pip下载地址wget https://pypi.python.org/packages/41/27/9a8d24e1b55bd8c85e4d022da2922cb206f183e2d18fee4e320c9547e751/pip-8.1.1.tar.gz#md5=6b86f11841e89c8241d689956ba99ed7 --no-check-certificate解压tar zxvf pip-8.1.1.tar.gz 安装 cd pip-8.1.1python setup.py install3.添加环境变量安装完之后，之后执行pip还是调用的以前的环境变量，需要手动添加环境变量mv /usr/bin/pip /usr/bin/pip26ln -s /usr/local/python27/bin/pip /usr/bin/再次查看版本pip -Vpip 8.1.1 from /usr/local/python27/lib/python2.7/site-packages/pip-8.1.1-py2.7.egg (python 2.7) 6.使用pip安装第三方库1234567891011121314151617181920如果报错locale.Error: unsupported locale setting加入环境变量：export LANGUAGE=en_US.UTF-8export LC_ALL=en_US.UTF-8pip install psutilpip install MySQLdb-pythonpip install django=1.8.2报错： pip install MySQLdb-pythonCollecting MySQLdb-python Retrying (Retry(total=4, connect=None, read=None, redirect=None)) after connection broken by 'ReadTimeoutError(\"HTTPSConnectionPool(host='pypi.python.org', port=443): Read timed out. (read timeout=15)\",)': /simple/mysqldb-python/ Could not find a version that satisfies the requirement MySQLdb-python (from versions: )No matching distribution found for MySQLdb-pythonYou are using pip version 8.1.1, however version 9.0.1 is available.You should consider upgrading via the 'pip install --upgrade pip' command.当安装中提示版本太低的时候，执行提示的命令进行升级即可pip install --upgrade pip升级完重新执行要安装的库","categories":[],"tags":[]},{"title":"git 常见操作","slug":"linux/git_2_operate","date":"2018-05-26T04:00:00.000Z","updated":"2019-05-19T14:18:38.607Z","comments":true,"path":"2018/05/26/linux/git_2_operate/","link":"","permalink":"http://wedvefv.github.io/2018/05/26/linux/git_2_operate/","excerpt":"","text":"创建分支1git branch new_branch 本地删除分支1git branch -D delete_branch 更新到远程删除分支12git checkout master git pull -u -u origin :delete_branch git pull 失败提示fatal: refusing to merge unrelated histories ,处理方法1git pull origin master --allow-unrelated-historiesn 查看提交提记录12345git loggit log -p -2 #查看最近两次的提交差异git log --stat #仅仅现实行数的变更git log --pretty=oneline #每次提交，在一行显示git log --pretty=format:\"%h - %an, %ar : %s\" #格式显示 选项 说明 %H 提交对象（提交）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（树）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（父）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（作者）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用-date =选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者（提交者）的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 待续……","categories":[{"name":"git","slug":"git","permalink":"http://wedvefv.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://wedvefv.github.io/tags/git/"}]},{"title":"windows 管道通信","slug":"linux/windows_pipe","date":"2017-01-08T06:11:00.000Z","updated":"2019-05-19T14:30:17.033Z","comments":true,"path":"2017/01/08/linux/windows_pipe/","link":"","permalink":"http://wedvefv.github.io/2017/01/08/linux/windows_pipe/","excerpt":"","text":"#windows 管道通信 思路如下：server端：1 建立一个可读可写的管道2 将cmd /c+命令建立的执行进程的输出（stdOutput）和错误(stdError)与管道写端关联。就是把cmd执行命令的结果写进管道。3 recv client端发来的命令比如： “dir”4 组合成字符串”c:/windows/system32/cmd.exe /cdir”5 利用字符串建立进程，就是执行的意思6 sleep(1000) 停止一秒，让进程完全执行完输出结果否则可能进程没执行完毕，就向下执行了，导致管道中只有部分cmd命令执行的结果。7 while循环ReadFile读取管道中的数据8 send发送数据给client端，显示 client端：这个很简单，建立一个阻塞的socket ，循环发送你想法的命令，到server端执行就可以了。 server端代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//server.cpp #include \"stdafx.h\"#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#pragma comment(lib, \"ws2_32.lib\")int main(int argc, char* argv[])&#123; SOCKET sClient; BYTE minorVer = 2; BYTE majorVer = 2; WSADATA wsaData; WORD sockVersion = MAKEWORD(minorVer, majorVer); if(WSAStartup(sockVersion, &amp;wsaData) != 0) return 0; SOCKET sListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(sListen == INVALID_SOCKET) &#123; printf(\"socket error \\n\"); return 0; &#125; sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(4500); sin.sin_addr.S_un.S_addr = INADDR_ANY; if(bind(sListen, (LPSOCKADDR)&amp;sin, sizeof(sin)) == SOCKET_ERROR) &#123; printf(\"bind error \\n\"); return 0; &#125; if(listen(sListen, 5) == SOCKET_ERROR) &#123; printf(\"listen error \\n\"); return 0; &#125; sClient =accept(sListen,NULL,NULL);// send(sClient,wMessage,strlen(wMessage),0); char rBuffer[4096] = &#123;0&#125;; char totalbuffer[4096] =&#123;0&#125;; char cmdline[256]=&#123;0&#125;; while(true) &#123; memset(cmdline,0,256); SECURITY_ATTRIBUTES sa; HANDLE hRead,hWrite; sa.nLength = sizeof(SECURITY_ATTRIBUTES); sa.lpSecurityDescriptor = NULL; sa.bInheritHandle = TRUE; if (!CreatePipe(&amp;hRead,&amp;hWrite,&amp;sa,0)) &#123; printf(\"CreatePipe Error\"); return 0; &#125; STARTUPINFO si; PROCESS_INFORMATION pi; si.cb = sizeof(STARTUPINFO); GetStartupInfo(&amp;si); si.hStdError = hWrite; si.hStdOutput = hWrite; si.wShowWindow = SW_HIDE; si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; GetSystemDirectory(cmdline,sizeof(cmdline)); strcat(cmdline,\"\\\\cmd.exe /c\"); char cmdbuff[256]; ZeroMemory(cmdbuff,sizeof(cmdbuff)); recv(sClient,cmdbuff,256,NULL); strncat(cmdline,cmdbuff,strlen(cmdbuff)); if (!CreateProcess(NULL,cmdline,NULL,NULL,TRUE,NULL,NULL,NULL,&amp;si,&amp;pi)) &#123; printf(\"CreateProcess Error\"); continue; &#125; ZeroMemory(cmdbuff,sizeof(cmdbuff)); CloseHandle(hWrite); DWORD dwRead; Sleep(1000); while(ReadFile(hRead,rBuffer,4096,&amp;dwRead,NULL)) &#123; char a[4] =&#123;0&#125;; sprintf(a,\"%d\",dwRead); //把数字转换成字符串放入数组 lstrcpy(totalbuffer,a); // 把总字节数写入数据最前面 lstrcat(totalbuffer,\"#\");//在加一个#符表示数字部分结束 lstrcat(totalbuffer,rBuffer);//缀数据部分 printf(\"%d\",dwRead); send(sClient,totalbuffer,dwRead+5,0); //发送 printf(\"%s\",totalbuffer); memset(rBuffer,0,4096); // 这是个死循环，一直读取管道中数据，所有要清零缓存 memset(totalbuffer,0,4096); &#125; &#125; return 0;&#125; client端代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include \"stdafx.h\"#include &lt;Winsock2.h&gt;#pragma comment(lib,\"ws2_32.lib\")int main(int argc, char* argv[])&#123; BYTE minorVer = 2; BYTE majorVer = 2; char recvBuf[4096]=&#123;0&#125;; char buffer[4096]=&#123;0&#125;; char temp[10]=&#123;0&#125;; int len = 0; int total = 0; int t =0; WSADATA wsaData; WORD sockVersion = MAKEWORD(minorVer, majorVer); if(WSAStartup(sockVersion, &amp;wsaData) != 0) return 0; //创建套接字 SOCKET sockClient = socket( AF_INET,SOCK_STREAM, 0 ); SOCKADDR_IN addrSrv; addrSrv.sin_addr.S_un.S_addr = inet_addr(\"172.28.125.137\"); //存server端ip ， addrSrv.sin_family = AF_INET; addrSrv.sin_port = htons(4500); char x[15]=&#123;0&#125;; //存放命令比如： cd ， dir ，ls ，pwd //向服务器发出连接请求 connect( sockClient, (SOCKADDR*)&amp;addrSrv, sizeof(SOCKADDR)); // 连接 while(1)&#123; ZeroMemory(recvBuf,sizeof(recvBuf)); // 清零缓存 if(0!=scanf(\"%s\",x))&#123; // 等待输入命令 send(sockClient,x,lstrlen(x), 0 ); total=recv( sockClient, buffer, 4096, 0 ); //接收一次，可能收不完哦 lstrcat(recvBuf,buffer); // 存到总buffer里面 memcpy(temp,buffer,strstr(buffer,\"#\")-buffer);// 从buffer里面取出来数字部分，就是#前的字符串 t = atoi(temp); // 转成数字 printf(\"%d\",t); while(total&lt;t)&#123; //如果第一次收到的小于这个数字，继续接收，存到临时buffer ZeroMemory(buffer,sizeof(buffer)); len=recv( sockClient, buffer, 4096, 0 ); total=len+total; // 取到的长度加上第一次的长度 lstrcat(recvBuf,buffer);// 这次取得放到总的recvBuf里面 &#125; // printf(\"%d\\n\",atoi(recvBuf)); printf(\"%s\\n\",recvBuf); printf(\"%d\\n\",strlen(recvBuf)); total =0; // 以下清零是为了下次while循环准备， len = 0; t =0; ZeroMemory(temp,sizeof(temp)); ZeroMemory(buffer,sizeof(buffer)); ZeroMemory(recvBuf,sizeof(recvBuf)); &#125; //接受数据 &#125; closesocket(sockClient); WSACleanup(); return 0;&#125; 注意：ReadFile是异步或同步模式 ，ReadFileEx只有异步模式","categories":[{"name":"windows","slug":"windows","permalink":"http://wedvefv.github.io/categories/windows/"}],"tags":[]},{"title":"apache_wsgi支持python脚本","slug":"linux/apache_wsgi","date":"2017-01-07T06:00:00.000Z","updated":"2019-03-02T10:16:37.993Z","comments":true,"path":"2017/01/07/linux/apache_wsgi/","link":"","permalink":"http://wedvefv.github.io/2017/01/07/linux/apache_wsgi/","excerpt":"","text":"apache支持python脚本配置httpd.conf追加：1234567891011LoadModule wsgi_module modules/mod_wsgi.so WSGIScriptAlias / C:/xampp/www/py/myweb/myweb/wsgi.py WSGIPythonPath C:/xampp/www/py/myweb #django 项目目录DocumentRoot \"C:/xampp/www/py/myweb/myweb\" #具体应用目录&lt;Directory \"C:/xampp/www\"&gt;Options Indexes FollowSymLinks Includes ExecCGIAllowOverride AllRequire all granted&lt;/Directory&gt; Options Indexes FollowSymLinks Includes ExecCGI禁止显示Apache目录列表-Indexes FollowSymLinks如何修改目录的配置以禁止显示 Apache 目录列表。减号和去掉indexes是一样的效果 ，都是不存在index时，不要显示目录结构，安全起见。xampp 中的不带减号，依然不可以访问目录。目前不知道原因。可能做了某些安全设置。 AllowOverride参数就是指明Apache服务器是否去找.htacess文件作为配置文件，如果设置为none,那么服务器将忽略.htacess文件，如果设置为All,那么所有在.htaccess文件里有的指令都将被重写。 Require all granted 允许所有请求访问资源","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[]},{"title":"nginx  support  php","slug":"linux/nginx_config","date":"2016-12-10T03:30:55.000Z","updated":"2019-03-02T10:16:37.988Z","comments":true,"path":"2016/12/10/linux/nginx_config/","link":"","permalink":"http://wedvefv.github.io/2016/12/10/linux/nginx_config/","excerpt":"","text":"ubuntu14.04 +nginx+php5-fpm一，安装Nginx apt-get install nginx 1，配置nginx nginx所有的配置在 /etc/nginx/nginx.conf中 nginx.conf配置里面包括了 include /etc/nginx/conf.d/.conf; include /etc/nginx/sites-enabled/; 这两个配置，所以这里面的配置也是有效的。 错误日志 error_log /var/log/nginx/error.log; 这里我们把配置写在 /etc/nginx/sites-available/default中 修改 root /usr/share/nginx/html; 这是网页的根目录，默认里面有一个index.html页面 index index.html index.htm修改成index index.php index.html index.htm; 增加 location ~ .php$ { try_files $uri =404; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params; } 2，保存文件，使配置生效 /etc/init.d/nginx reload 3，启动nginx /etc/init.d/nginx start 4，在 /usr/share/nginx/html下新建index.php &lt;? php phpinfo(); ?&gt; 二 安装phpsudo apt-get install php5-fpm sudo apt-get install php5-gd # Popular image manipulation library; used extensively by Wordpress and it’s plugins.sudo apt-get install php5-cli # Makes the php5 command available to the terminal for php5 scriptingsudo apt-get install php5-curl # Allows curl (file downloading tool) to be called from PHP5sudo apt-get install php5-mcrypt # Provides encryption algorithms to PHP scriptssudo apt-get install php5-mysql # Allows PHP5 scripts to talk to a MySQL Databasesudo apt-get install php5-readline # Allows PHP5 scripts to use the readline function 查看php5运行进程 ps -waux | grep php5 打开关闭php5进程 sudo service php5-fpm stopsudo service php5-fpm startsudo service php5-fpm restartsudo service php5-fpm status 配置php5监听端口 /etc/php5/fpm/pool.d/www.conf 把 listen = /var/run/php5-fpm.sock 改为 listen = 127.0.0.1:9000 重新运行php进程","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[]},{"title":"vim-markdown插件","slug":"linux/vim-markdown","date":"2016-10-27T07:30:00.000Z","updated":"2019-05-19T14:18:38.610Z","comments":true,"path":"2016/10/27/linux/vim-markdown/","link":"","permalink":"http://wedvefv.github.io/2016/10/27/linux/vim-markdown/","excerpt":"","text":"首先为了高亮显示markdown文件 ，安装vim-markdown插件(vundle管理的)12Plugin 'godlygeek/tabular'Plugin 'tpope/vim-markdown' 安装时时预览插件 只支持macos/linux ,打开markdown文件就会出现浏览器窗口预览1\"Plugin 'suan/vim-instant-markdown' #windows 下有一个python2支持的插件，也能预览 需要python2的支持–python2.7就可以。需要nodejs的支持，自行安装。完成后： 1npm -g install instant-markdown-d 在vim配置文件中添加: 1Plugin 'suan/vim-instant-markdown' 打开vim 更新安装插件 ： 1:PluginInstall","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"http://wedvefv.github.io/tags/vim/"}]},{"title":"vim-emmet插件/html/css","slug":"linux/vim-emmet","date":"2016-10-26T16:00:00.000Z","updated":"2019-05-19T14:18:38.610Z","comments":true,"path":"2016/10/27/linux/vim-emmet/","link":"","permalink":"http://wedvefv.github.io/2016/10/27/linux/vim-emmet/","excerpt":"","text":"emmet-vim 插件就是以前的zencoding安装 可以git clone ，可以在vim里面安装PluginInstall 来说一下快捷键快捷键一： 输入html：5 按下ctrl+y 松开后在按逗号（英文的哦）立刻展开成如下了12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; html:xt 就是兼容的html版本 快捷键二：div#page&gt;div.logo+ul#navigation2&gt;li5&gt;a也是ctrl+y，松开后按英文逗号，展开后是：1234567891011121314151617&lt;div id=\"page\"&gt; &lt;div class=\"logo\"&gt;&lt;/div&gt; &lt;ul id=\"navigation\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"navigation\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 可以看出来： #号是表示id.表示class+ 表示同一级的元素可以用*n 产生多个同名同级的元素>表示要包含的元素#xxx 默认的这个表示默认div元素，且id为xxx","categories":[{"name":"vim","slug":"vim","permalink":"http://wedvefv.github.io/categories/vim/"}],"tags":[]},{"title":"vim 乱码","slug":"linux/vim_luanma","date":"2016-10-26T10:37:00.000Z","updated":"2019-05-19T14:18:38.610Z","comments":true,"path":"2016/10/26/linux/vim_luanma/","link":"","permalink":"http://wedvefv.github.io/2016/10/26/linux/vim_luanma/","excerpt":"","text":"首先 中文os下，我们一般的设置是：123456set encoding=utf-8 \"设置gvim内部编码set fileencoding=utf-8 \"设置当前文件编码set fileencodings=gbk,utf-8,shift_jis,ucs-bom,latin1,gb2312,cp936,cp932 设置支持打开的文件的编码set termencoding=utf-8set guifont=DejaVu\\\\ Sans\\\\ Mono\\\\:h13 上述，set fileencodings设置的文字编码解析顺位，对于中文是可以解析出来的,shift_jis编码的文件，就会出现乱码。除非你把shift_jis设置第一位： 1set fileencodings=shift_jis,gbk,utf-8,ucs-bom,latin1,gb2312,cp936,cp932 对于日文os ，安装gvim后，需要如下设置：由于本地ANSI是cp932 , 所以把cp932 放在第一或者第二的位置，如果放到第三或者后面就会出现shift_jis编码的日文打开后是文本乱码现象。 123456789set encoding=utf-8 \"设置gvim内部编码set fileencoding=utf-8 \"设置当前文件编码set fileencodings=CP932,utf-8,gbk,,ucs-bom,latin1,gb2312,cp936 #设置支持打开的文件的编码set termencoding=utf-8set guifont=DejaVu\\ Sans\\ Mono\\:h13 set guifontwide=NSimsun\\:h14 #设置新宋体 由于DejaVu Sans Mono 字体是英文字符字体，无法正确显示宽字体，所以需要特别加入12set guifontwide=NSimsun\\:h14 #设置新宋体 ，显示汉字 所以大家在自己的sublime 或者vim中设置编辑器字体DejaVu Sans Mono就好像可以显示正确的汉字和英文，其实我们设置的只是英文字符显示的样式。汉字其实是系统本地ANSI编码。 本地ANSI编码世界上每种语言对应的windows 系统都有各自的ANSI，互相不兼容。 比如 中文ANSI == GBK(中文) ，gbk是gb2312(简体中文)的扩展，包含繁体，日文片假名。cp936就是gbk 日文ANSI == Windows-31J 就是cp932.shift_jis也是一种日文字符编码,不过，只实现了cp932的部分，所以cp932编码的东东，shift_jis可能乱码。shift_jis编码的，cp932一定正常显示。 这是微软早起应对不同国家一种混合的编码：字母+对应的国家文字,这种字符也是多字节字符。比如：中文ANSI,字母数字是1字节 ,汉字是2字节。两种语言文字有可能在一起就显示乱码。不过微软提供了本地ANSI转换为标准unicode字符的方案，通过代码页转换表技术这一过度方案。 nnicode编码规范unicode 是将全世界所有的字符都统一编码的方案(规范))。那么字符a的编码本来是1byte ,现在统一和一个汉字一样长了。那么问题来了，字符串是’\\0’字符结尾。世界上的很久以前写的c程序，就没办法用了。所以说unicode应该早点出来。 有了这种全字符集，解决了乱码，却没法用，蛋疼吧，可是utf8这一实现字符保存，传输的方案出现了。因为utf8是可变长的。不同位段，长度不一致。 utf-8编码12345678910UCS-2编码(16进制) UTF-8 字节流(二进制)0000 - 007F 0xxxxxxx0080 - 07FF 110xxxxx 10xxxxxx0800 - FFFF 1110xxxx 10xxxxxx 10xxxxxx 例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001，用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。 可见UTF-8是变长的，将Unicode编码为00000000-0000007F的字符，用单个字节来表示； 00000080-000007FF的字符用两个字节表示；00000800-0000FFFF的字符用3字节表示。因为目前为止Unicode-16规范没有指定FFFF以上的字符，所以UTF-8最多是使用3个字节来表示一个字符。但理论上来说，UTF-8最多需要用6字节表示一个字符。 UTF-8兼容ASCII。 #utf16编码utf-16 和unicode规范是一致的，所以不兼容ascii。以上信息来源参考：","categories":[],"tags":[]},{"title":"atom编辑器","slug":"linux/atom","date":"2016-10-09T07:30:30.000Z","updated":"2019-05-19T14:18:38.610Z","comments":true,"path":"2016/10/09/linux/atom/","link":"","permalink":"http://wedvefv.github.io/2016/10/09/linux/atom/","excerpt":"","text":"atom 编辑器比较：优点：开源，免费，可定制型强，中文支持比sublime做的好，sublime是收费的。缺点：稍微有一点慢，相对于sublime，画面类似sublime，体积也比较大。 发展： vim基本都是插件扩展， 插件一般是vimscript编写，现在为了可维护性，加入python支持。 sublime：也是插件扩展，主要是json配置，可扩展性没atom好。收费，维护仅由编写者维护。 atom：开源，界面类似sublime，插件脚本由js编写，利于扩展，社区支持强大。有人说atom是编辑器 的集大成者。 windows下安装 需要node.js支持（安装了node.js ，安装npm包管理器（为了解决nodejs代码的部署问题）） 安装atom编辑器 打开编辑器，packages-&gt;settings-view-&gt;manager packages ,安装插件即可。 网络被公司设置代理的，需要设置~/.atom/.apmrc 文件如下：123strict-ssl=falsehttp-proxy=http://xxxx:xxhttps-proxy=https://xxxx:xx 有些时候还是提示 atom.io:433访问地址错误。 那么可以登录：https://atom.io/packages/ 搜索需要的插件，进入Repo页面。复制 git需要的地址。例如qolor插件地址：https://github.com/DavidLGoldberg/qolor.git 进入~/.atom/packages目录下, 打开cmd，执行git clone https://github.com/DavidLGoldberg/qolor.git cd qolor 进入qolor目录，在执行npm install 就会安装 qolor插件了。 npm如果需要设置代理，配置文件是~/.npmrc ，写入： 12registry=http://registry.cnpmjs.org/proxy=http://xxx:xx 测试环境 windows 8.1 nodejs-4.6.0 python2.7.9 ~表示用户目录。我的是 c:/users/administrator/","categories":[{"name":"atom","slug":"atom","permalink":"http://wedvefv.github.io/categories/atom/"}],"tags":[]},{"title":"nerdtree插件","slug":"linux/vim_nerdtree","date":"2016-10-06T12:07:30.000Z","updated":"2019-05-19T14:18:38.611Z","comments":true,"path":"2016/10/06/linux/vim_nerdtree/","link":"","permalink":"http://wedvefv.github.io/2016/10/06/linux/vim_nerdtree/","excerpt":"","text":"#nerdtree插件，可以在vim左侧显示目录 使用说明1、在linux命令行界面，输入vim 2、输入 :NERDTree ，回车 3、进入当前目录的树形界面，通过小键盘上下键，能移动选中的目录或文件 4、目录前面有+或者&gt;号，摁Enter会展开目录，文件前面是-号，摁Enter会在右侧窗口展现该文件的内容，光标自动移到右侧文件窗口。 5、ctr+w+h 光标移到左侧树形目录，ctrl+w+l 光标移到右侧文件显示窗口。多次摁 ctrl+w，光标自动在左右侧窗口切换 6、光标focus左侧树形窗口，摁? 弹出NERDTree的帮助，再次摁？关闭帮助显示 7、输入:q回车，关闭光标所在窗口 进阶用法o 打开关闭文件或者目录t 在标签页中打开T 在后台标签页中打开! 执行此文件p 到上层目录P 到根目录K 到第一个节点J 到最后一个节点u 打开上层目录m 显示文件系统菜单（添加、删除、移动操作）? 帮助q 关闭","categories":[{"name":"vim","slug":"vim","permalink":"http://wedvefv.github.io/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://wedvefv.github.io/tags/vim/"}]},{"title":"ajax简介","slug":"language/html/ajax","date":"2016-10-06T12:04:30.000Z","updated":"2019-05-19T14:30:17.030Z","comments":true,"path":"2016/10/06/language/html/ajax/","link":"","permalink":"http://wedvefv.github.io/2016/10/06/language/html/ajax/","excerpt":"","text":"1.ajax 简介ajax = 异步javascript+XMLAAJAX是基于现有的Internet标准，并且联合使用它们：XMLHttpRequest 对象 (异步的与服务器交换数据)JavaScript/DOM (信息显示/交互)CSS (给数据定义样式)XML (作为转换数据的格式)lamp AJAX应用程序与浏览器和平台无关的！实现不刷新整个页面，实现页面动态更新的技术。 ajax工作原理： 2.ajax实例 1.首先建立XMLHttpRequest对象，区分不同的浏览器版本，IE5,IE6不支持直接建立XMLHttpRequest对象，所以： 12345678var xmlhttp;if(window.XMLHttpRequest)&#123; //如果为真，则支持XMLHttpRequest对象 xmlhttp = new XMLHttpRequest();&#125;else&#123; //code for IE5,6 xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\";)&#125; 2.XMLHttpRequest对象用于和服务器交换数据 open方法用于发送请求，参数1：方法，参数2：url，参数3:异步/同步 xmlhttp.open(“GET”,”ajax_info.txt”,true) send方法也用于请求，不过只支持post请求，参数：string xmlhttp.send(string); GET和POST的区别： GET更简单，更快，大部分情况都能用。以下情况使用POST： 无法使用缓存文件更新服务器上的文件或数据库。 发送大量数据到服务器。 发送用户输入的未知字符到服务器时。 例子get请求：12xmlhttp.open(\"GET\",\"demo_get2.html?fname=Henry&amp;lname=Ford\",true);xmlhttp.send(); post请求： 如果post表单那样的提交数据，需要添加http头12345678910xmlhttp.open(\"POST\",\"ajax_test.html\",true);xmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");xmlhttp.send(\"fname=Henry&amp;lname=Ford\");setRequestHeader方法：setRequestHeader(header,value) 向请求添加 HTTP 头。header: 规定头的名称value: 规定头的值 Async=true 使用XMLRequest.open()方法时，一般在ajax第三个参数必须是true（异步）而且规定请求就绪时执行的函数。也就是定义 XMLHttpRequest.onreadystatechange 事件函数。当请求完成时，触发该函数，类似定时器。 因为web请求也许需要一段时间，所以发送异步请求，等待请求的这段时间可以执行其他代码。请求得到返回时，再执行onreadystatechange中的函数。 12345678910xmlhttp.onreadystatechange=function() // &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)//请求正确返回http code 200时 //执行修改id为mydiv的html元素内容。 &#123; document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; &#125; &#125;xmlhttp.open(\"GET\",\"ajax_info.txt\",true); //请求ajax_info.txt文件，xmlhttp.send(); #Async=false 不推荐，对于小型的请求也下可以。因为javascript会等待服务器返回后才继续向下执行。如果服务器繁忙，应用程序会挂起或者挂掉。 XMLHttpRequest响应如果返回200,就可以使用","categories":[{"name":"html","slug":"html","permalink":"http://wedvefv.github.io/categories/html/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://wedvefv.github.io/tags/ajax/"}]},{"title":"DLL导出方法","slug":"linux/dll_export","date":"2016-10-06T12:04:30.000Z","updated":"2019-05-19T14:30:17.032Z","comments":true,"path":"2016/10/06/linux/dll_export/","link":"","permalink":"http://wedvefv.github.io/2016/10/06/linux/dll_export/","excerpt":"","text":"DLL导出方法dll导出方法1 ：模块定义def文件，不支持c++的重载，以c的方式编译，导出的函数名不被修改，这样显示调用dll取得函数地址就没事。提供给vb，python等语言,需要_stdcall约定(函数自己清理堆栈)，这样无论是c文件还是c++文件，导出函数都会被改名字。所以dll做成必须要用def文件，否则找不到名字。除非你记得修饰过的函数名。 dll导出方法2：函数声明头文件声明如下：__declspec(dllexport)这种方式，方便c++代码的重载，同名函数不同参数，导出名字会被修饰，所以能区分开。这种方式实现了DLL的隐式调用（只提供dll的导出符号lib文件，就可直接调用函数，（只是导出函数符号，没有具体实现，不同于静态库的lib文件），def文件导出的dll不能用隐式调用，只能取得函数地址getProcAddress方式） 1234567891011121314151617181920212223#ifndef _EXSOPINF_H_#define _EXSOPINF_H_#ifdef __cplusplus //cpp文件时，用c方式编译导出，不会修改导出函数名。但是_stdcall//调用也会修改，_cdecl(默认)调用不会修改extern \"C\" &#123;#endif__declspec(dllexport) DWORD WINAPI function1( LPCSTR lpszFolderName, LPSTR lpszCode );__declspec(dllexport) DWORD WINAPI function2( LPCSTR lpszFolderName, LPSTR lpszCode );#ifdef __cplusplus&#125;#endif#endif函数定义时，也需要在函数名前：加入修饰__declspec(dllexport) DWORD WINAPI function1(LPCSTR lpszFolderName, LPSTR lpszCode )&#123; return 0;&#125;其中WINAPI是调用约定。 常见调用约定123456789101112131415161718192021222324252627282930调用协议常用场合__stdcall：Windows API默认的函数调用协议。__cdecl：C/C++默认的函数调用协议。__fastcall：适用于对性能要求较高的场合。函数参数入栈方式__stdcall：函数参数由右向左入栈。__cdecl：函数参数由右向左入栈。__fastcall：从左开始不大于4字节的参数放入CPU的ECX和EDX寄存器，其余参数从右向左入栈。问题一：__fastcall在寄存器中放入不大于4字节的参数，故性能较高，适用于需要高性能的场合。栈内数据清除方式__stdcall：函数调用结束后由被调用函数清除栈内数据。__cdecl：函数调用结束后由函数调用者清除栈内数据。__fastcall：函数调用结束后由被调用函数清除栈内数据。问题一：不同编译器设定的栈结构不尽相同，跨开发平台时由函数调用者清除栈内数据不可行。问题二：某些函数的参数是可变的，如printf函数，这样的函数只能由函数调用者清除栈内数据。问题三：由调用者清除栈内数据时，每次调用都包含清除栈内数据的代码，故可执行文件较大。C语言编译器函数名称修饰规则__stdcall：编译后，函数名被修饰为“_functionname@number”。__cdecl：编译后，函数名被修饰为“_functionname”。__fastcall：编译后，函数名给修饰为“@functionname@nmuber”。注：“functionname”为函数名，“number”为参数字节数。注：函数实现和函数定义时如果使用了不同的函数调用协议，则无法实现函数调用。C++语言编译器函数名称修饰规则__stdcall：编译后，函数名被修饰为“?functionname@@YG******@Z”。__cdecl：编译后，函数名被修饰为“?functionname@@YA******@Z”。__fastcall：编译后，函数名被修饰为“?functionname@@YI******@Z”。注：“******”为函数返回值类型和参数类型表。注：函数实现和函数定义时如果使用了不同的函数调用协议，则无法实现函数调用。C语言和C++语言间如果不进行特殊处理，也无法实现函数的互相调用。 _stdcall与_cdecl的区别(函数调用方式)(1). 是C Declaration的缩写，表示C语言默认的函数调用方法，实际上也是C++的默认的函数调用方法。(2). 所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。具体所示：调用方的函数调用-&gt;被调用函数的执行-&gt;被调用函数的结果返回-&gt;调用方清除调整堆栈。(3). 被调用函数无需要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。总的来说函数的参数个数可变的(就像printf函数一样)，因为只有调用者才知道它传给被调用函数几个参数，才能在调用结束时适当地调整堆栈。(4). 因为每个调用的地方都需要生成一段调整堆栈的代码，所以最后生成的文件较大。 _stdcall(CALLBACK/WINAPI)(1). 是Standard Call的缩写，要想函数按照此调用方式必须在函数名加入stdcall，通常 win32 api 应该是_stdcall调用规则。通过VC++编写的DLL欲被其他语言编写的程序调用，应将函数的调用方式声明为_stdcall 方式，WINAPI都采用这种方式。(2). 所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是this指针。具体所示：调用方的函数调用-&gt;被调用函数的执行-&gt; 被调用方清除调整堆栈-&gt;被调用函数的结果返回。(3). 这些堆栈中的参数由被调用的函数在返回后清除，使用的指令是 retn X，X表示参数占用的字节数，CPU在ret之后自动弹出X个字节的堆栈空间。称为自动清栈。(4). 函数在编译的时候就必须确定参数个数，并且调用者必须严格的控制参数的生成，不能多，不能少，否则返回后会出错。总的来说，就是函数的参数个数不能是可变的。是从 _cdecl 修改而来, _stdcall 不支持可变参数,并且清栈由被调用者负责,其他的都一样(5). 因为只需在被调用函数的地方生成一段调整堆栈的代码，所以最后生成的文件较小。 PASCAL 是Pascal语言的函数调用方式，也可以在C/C++中使用，参数压栈顺序与前两者相反。返回时的清栈方式忘记了。。。 _fastcall 是编译器指定的快速调用方式。由于大多数的函数参数个数很少，使用堆栈传递比较费时。因此_fastcall通常规定将前两个（或若干个）参数由寄存器传递，其余参数还是通过堆栈传递。不同编译器编译的程序规定的寄存器不同。返回方式和_stdcall相当。 _thiscall 是为了解决类成员调用中this指针传递而规定的。_thiscall要求把this指针放在特定寄存器中，该寄存器由编译器决定。VC使用ecx，Borland的C++编译器使用eax。返回方式和_stdcall相当。 _fastcall 和 _thiscall涉及的寄存器由编译器决定，因此不能用作跨编译器的接口。所以Windows上的COM对象接口都定义为_stdcall调用方式。 C中不加说明默认函数为_cdecl方式（C中也只能用这种方式），C++也一样，但是默认的调用方式可以在IDE环境中设置。 带有可变参数的函数必须且只能使用_cdecl方式，例如下面的函数: int printf(char * fmtStr, …); int scanf(char * fmtStr, ...); 函数名修饰(1). _cdecl ：对于_cdecl而言，如果对于定义在C程序文件(编译器会通过后缀名为.C判断)的输出函数，函数名会保持原样；对于定义在C++程序文件中的输出函数，函数名会被修饰(见10)。为使函数名不被修饰，有两种方法：A.可通过在前面加上extern “c”以去除函数名修饰；B. 可通过.def文件去除函数名修饰。 (2). _stdcall：无论是C程序文件中的输出函数还是C++程序文件中的输出函数，函数名都会被修饰。对于定义在C++程序文件中的输出函数，好像更复杂，和_cdecl的情况类似。去除函数名修饰方法：只能通过.def文件去除函数名修饰。 函数名修饰规则：(1). 为什么要函数名修饰： 函数名修饰就是编译器在编译期间创建的一个字符串，用来指明函数的定义和原型。LINK程序或其他工具有时需要指定函数的名字修饰来定位函数的正确位置。多少情况下程序员并不需要知道函数的名字修饰，LINK程序或其他工具会自动区分他们。当然，在某些情况下需要指定函数名修饰，例如在c++程序中，为了让LINK程序或其他工具能够匹配到正确的函数名字，就必须为重载函数后一些特殊函数(如构造函数和析构函数)指定名字修饰。另一种需要指定函数名修饰的情况是在汇编程序中调用C或C++函数。(2). C语言： 对于_stdcall调用约定，编译器和链接器会在输出函数名前加上一个下划线前缀，函数名后面加上一个“@”符号和其参数的字节数，例如_functionname@number。_cdecl调用约定仅在输出函数名前加上一个下划线前缀，例如_functionname。_fastcall调用约定在输出函数名前加上一个 “@“符号，后面也是一个”@“符号和其参数的字节数，例如@functionname@number。(3). C++语言： C++的函数名修饰规则有些复杂，但是信息更充分，通过分析修饰名不仅能够知道函数的调用方式，返回值类型，参数个数甚至参数类型。不管cdecl，fastcall还是stdcall调用方式，函数修饰都是以一个“?”开始，后面紧跟函数的名字，再后面是参数表的开始标识和按照参数类型代号拼出的参数表。对于stdcall方式，参数表的开始标识是“@@YG”，对于cdecl方式则是“@@YA”，对于fastcall方式则是“@@YI”。参数表的拼写代号如下所示：X–voidD–charE–unsigned charF–shortH–intI–unsigned intJ–longK–unsigned long（DWORD）M–floatN–double_N—boolU—struct 指针的方式有些特别，用PA表示指针，用PB表示const类型的指针。后面的代号表明指针类型，如果相同类型的指针连续出现，以“0”代替，一个“0”代表一次重复。U表示结构类型，通常后跟结构体的类型名，用“@@”表示结构类型名的结束。函数的返回值不作特殊处理，它的描述方式和函数参数一样，紧跟着参数表的开始标志，也就是说，函数参数表的第一项实际上是表示函数的返回值类型。参数表后以“@Z”标识整个名字的结束，如果该函数无参数，则以“Z”标识结束。下面举两个例子，假如有以下函数声明：int Function1(char *var1,unsigned long);其函数修饰名为“?Function1@@YGHPADK@Z”，而对于函数声明：oid Function2();其函数修饰名则为“?Function2@@YGXXZ” 。对于C++的类成员函数（其调用方式是thiscall），函数的名字修饰与非成员的C++函数稍有不同，首先就是在函数名字和参数表之间插入以“@”字符引导的类名；其次是参数表的开始标识不同，公有（public）成员函数的标识是“@@QAE”,保护（protected）成员函数的标识是“@@IAE”,私有（private）成员函数的标识是“@@AAE”，如果函数声明使用了const关键字，则相应的标识应分别为“@@QBE”，“@@IBE”和“@@ABE”。如果参数类型是类实例的引用，则使用“AAV1”，对于const类型的引用，则使用“ABV1”。 查看函数的名字修饰 有两种方式可以检查你的程序中的函数的名字修饰：使用编译输出列表或使用Dumpbin工具。使用/FAc，/FAs或/FAcs命令行参数可以让编译器输出函数或变量名字列表。使用dumpbin.exe /SYMBOLS命令也可以获得obj文件或lib文件中的函数或变量名字列表。此外，还可以使用 undname.exe 将修饰名转换为未修饰形式。 _beginthread需要_cdecl的线程函数地址，_beginthreadex和_CreateThread需要_stdcall的线程函数地址。1234567#define CALLBACK __stdcall //这就是传说中的回调函数#define WINAPI __stdcall //这就是传说中的WINAPI#define WINAPIV __cdecl#define APIENTRY WINAPI //DllMain的入口就在这里#define APIPRIVATE __stdcall#define PASCAL __stdcall","categories":[{"name":"windows","slug":"windows","permalink":"http://wedvefv.github.io/categories/windows/"}],"tags":[]},{"title":"syntastic vim  静态分析插件","slug":"linux/vim_syntastic","date":"2016-10-05T12:10:30.000Z","updated":"2019-05-19T14:18:38.611Z","comments":true,"path":"2016/10/05/linux/vim_syntastic/","link":"","permalink":"http://wedvefv.github.io/2016/10/05/linux/vim_syntastic/","excerpt":"","text":"syntastic vim 静态分析插件，里面带有各种语言的分析工具，是为了代码补全提示1234567891011121314配置如下：_vimrc文件加入：Bundle 'scrooloose/syntastic'打开vim： BundleInstall 安装插件。配置如下：let g:syntastic_error_symbol='&gt;&gt;'let g:syntastic_warning_symbol='&gt;'let g:syntastic_check_on_open=1let g:syntastic_check_on_wq=0let g:syntastic_enable_highlighting=1#下面一行是指定使用哪种工具分析python语法和javascript语法let g:syntastic_python_checkers=['pyflakes'] \" 使用pyflakes,速度比pylint快let g:syntastic_javascript_checkers = ['jsl', 'jshint']let g:syntastic_html_checkers=['tidy', 'jshint']","categories":[{"name":"vim","slug":"vim","permalink":"http://wedvefv.github.io/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://wedvefv.github.io/tags/vim/"}]},{"title":"linux常用函数手册","slug":"linux/linux_c_help","date":"2016-10-05T12:06:30.000Z","updated":"2019-03-02T10:16:37.986Z","comments":true,"path":"2016/10/05/linux/linux_c_help/","link":"","permalink":"http://wedvefv.github.io/2016/10/05/linux/linux_c_help/","excerpt":"","text":"linuxlinux常用函数手册","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[]},{"title":"html5标签","slug":"language/html/html5_tags","date":"2016-08-10T03:30:55.000Z","updated":"2019-05-19T14:30:17.030Z","comments":true,"path":"2016/08/10/language/html/html5_tags/","link":"","permalink":"http://wedvefv.github.io/2016/08/10/language/html/html5_tags/","excerpt":"","text":"html5标签总结1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292301. &lt;!----&gt; 注释2. &lt;!DOCTYPE&gt; 定义html文本类型3. &lt;a&gt; 定义超链接4. &lt;abbr&gt; 把一段字符串用缩写表示&lt;abbr title =\"People world\"&gt;PW &lt;/abbr&gt;5. &lt;address&gt; 在article元素内部，表示该文章的作者身份信息6. &lt;applet&gt; 定义嵌入的applet ，html5不支持了。请用object代替7. &lt;acronym&gt; html5不支持了，请用&lt;abbr代替哦8. &lt;area&gt; 标签定义图像映射内部的区域，图像中部分区域可以点击，就是说有链接的9. 两栏式架构 |header---------------------------------------------------------------------------------------|顶部 |nav------------------------------------------------------------------------------------------|外链 |article---包含&lt;section&gt;-----------------&lt;aside&gt;--------------------------|文章主体--段落或章节-侧边栏 |footer---------------------------------------------------------------------------------------|底部 以前都是用&lt;div id=\"header\"&gt; &lt;div id =\"nav\"&gt;...... 这样来定义页面的结构，html5新定义了这些，避免div太多混乱.10. &lt;aside&gt; 可用于文章的侧边栏11. &lt;audio&gt; 定义声音链接12. &lt;b&gt; 定义粗体字体，强调13. &lt;base&gt; 放在head里面，用于页面中的链接的基地址。后面的链接就可以写相对地址了。 比如base =www.xxx000.com/img ,链接一个图片就可以不写全路径，直接src=\"xxx.jpeg\"14. &lt;basefont&gt; html不支持了。设置文档中所有字体的默认颜色，大小15. &lt;bdi&gt; 通过脱离父元素的文本设置方向16. &lt;bdo&gt; 定义文本方向，指定dir属性是rtl还是ltr17. &lt;big&gt; html不支持了。请用css控制 ，制作更大的文本18. &lt;blockquote&gt;摘自另一个源的块引用19. &lt;body&gt; 定义文档主体20. &lt;br &gt; 换行符21. &lt;button&gt; 定义按钮，多种属性，可以是按钮，提交，重置.....22. &lt;canvas&gt; 只是承载图形的容器。需要script脚本绘制图形，然后传给canvas标签中23. &lt;caption&gt; 放在table后面，定义表格的标题的24. &lt;canter&gt; 5不支持了，请用CSS定义居中25. &lt;cite&gt; 定义歌曲，影视，书籍等作品的标题26. &lt;code&gt; HTML5 &lt;em&gt; &lt;strong&gt; &lt;dfn&gt; &lt;code&gt; &lt;samp&gt; &lt;kbd&gt; &lt;var&gt; &lt;cite&gt; 等短标签， 不推荐使用了。css能有更丰富的表现27. &lt;col&gt; 只能在table或者colgroup元素内使用，定义一列或多列表格的属性值。默认 至少一列，只有span属性能用了，其他的用css28. &lt;colgroup&gt; 里面只能有col元素 H5已经不支持大部分属性了，用于对表格中的列进行组合， 并格式化。要区别于col29. &lt;command&gt; 可以指定消息事件处理函数。目前只支持ＩＥ30. &lt;datalist&gt; 定义选项列表。和input元素配合使用，对于输入框提示作用31. &lt;dd&gt; dl定义列表，dt定义项目,dd对项目进行描述32. &lt;del&gt; 定义已经删除的文本。中划线33. &lt;details&gt; 描述文档中的某个细节。目前只chrome支持34. &lt;div&gt; 定义文档中的分割和部分。以便对块元素进行格式化。35. &lt;dl&gt; 定义一个list 配合dt和dd使用。dt是项目。dd是项目具体描述36. &lt;em&gt; 被强调的文本。一般配合css使用啦。37. &lt;embed&gt; 定义嵌入的内容。属性src=\"\"38. &lt;fieldset&gt; 表单中 配合legend标签定义fieldset的标题。相当与通过legend定义的标题话一个框框,\\ 把许多表单元素圈住。39. &lt;figcaptio&gt; 标签定义 figure 元素的标题（caption）。40. &lt;figure&gt; 标签规定独立的流内容（图像、图表、照片、代码等等）。定义的内容与主内容无关， 定义的内容不存在时也不对文档有影响41. &lt;font&gt; H5不支持了，请用CSS42. &lt;footer&gt; 定义页脚，作者信息等等43. &lt;form&gt; form 元素包含一个或多个表单元素，比如： button input keygen object output select textarea44. &lt;frame&gt; H5不支持了。45. &lt;frameset&gt; 5也不支持了。46. &lt;h1-h6&gt; 定义标题大小47. &lt;head&gt; 头部元素，下面是可用在 head 部分的标签： base link meta script style title48. &lt;header&gt; 定义文档的页眉49. &lt;hgroup&gt; 对标题进行组合 .H5的新标签50. &lt;hr&gt; 定义主题变化，表现为一条水平线。51. &lt;html&gt; 定义html文档52. &lt;i&gt; 斜体。应该使用CSS53. &lt;iframe&gt; 创建包含另个文档的内嵌框架。54. &lt;img&gt; 必须要的两个属性src和alt（指定图片表述，以备图片无法加载时显示文字）55. &lt;input&gt; 定义用户的输入字段，根据不同的 type 属性，输入字段有多种形态。输入字段可以是 文本字段、复选框、密码字段、单选按钮、按钮等等。56. &lt;ins&gt; 地难以插入文本，一般和del一起使用。ins定义的文字会加入下划线57. &lt;keygen&gt; 类似input,定义表单的密钥生成器字段。H5新标签58. &lt;kbd&gt; 表示文本是键盘输入的59. &lt;label&gt; input标签配合使用。点击label标签定义的文字，相当与自动点击input控件60. &lt;legend&gt; 给一下元素定义标题的：&lt;fieldset&gt;、&lt;figure&gt;、&lt;details&gt;。61. &lt;li&gt; 定义列表项。在&lt;ul&gt;标签和&lt;ol&gt;标签中使用/有序和无序列表62. &lt;link&gt; 文档链接外部资源的。大部分用来链接外部样式表css文件63. &lt;map&gt; 定义图像区域映射，name属性和ｉｍｇ的usemap属性关联，包含area元素。64. &lt;mark&gt; 突出显示文本。文本背景黄色。65. &lt;menu&gt; 标签定义菜单列表。用于排列表单控件 &lt;menu&gt; &lt;li&gt;&lt;input type=\"checkbox\" /&gt;Red&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\" /&gt;blue&lt;/li&gt; &lt;/menu&gt;67. &lt;meta&gt; 定义页面相关信息。位于head中定义关键词，利于搜索引擎检索： &lt;meta name=\"keywords\" content=\"HTML, CSS, XML, XHTML, JavaScript\" /&gt; 定义对页面的描述： &lt;meta name=\"description\" content=\"w3c html web 技术标准教程。\" /&gt; 每５秒刷新一次页面： &lt;meta http-equiv=\"refresh\" content=\"5\" /&gt;68. &lt;meter&gt; 定义度量范围，可以用属性,max/min 也可以用文本中定义范围。69. &lt;nav&gt; 定义导航栏的链接的部分70. &lt;noframes&gt; H5不支持了，用于不能显示框架的时候提示文本71. &lt;noscript&gt; 当不支持脚本时。显示提示的文本72. &lt;object&gt; 定义一个嵌入的对象，多媒体等。图像请使用ｉｍｇ代替。大部分html4中的属性H5不支持了。73. &lt;ol&gt; 有序列表74. &lt;optgroup&gt; 组合选项： &lt;select&gt; &lt;optgroup label=\"Swedish Cars\"&gt; &lt;option value =\"volvo\"&gt;Volvo&lt;/option&gt; &lt;option value =\"saab\"&gt;Saab&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=\"German Cars\"&gt; &lt;option value =\"mercedes\"&gt;Mercedes&lt;/option&gt; &lt;option value =\"audi\"&gt;Audi&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt;75. &lt;optlon&gt; 定义一个下拉列表选项：76. &lt;select&gt; &lt;option value=\"volvo\"&gt;Volvo&lt;/option&gt; &lt;option value=\"saab\"&gt;Saab&lt;/option&gt; &lt;option value=\"opel\" selected=\"selected\"&gt;Opel&lt;/option&gt; &lt;option value=\"audi\"&gt;Audi&lt;/option&gt; &lt;/select&gt;76. &lt;output&gt; 标签定义不同类型的输出，比如脚本的输出。: &lt;form oninput=\"x.value=parseInt(a.value)+parseInt(b.value)\"&gt;0&lt;input type=\"range\" id=\"a\" value=\"50\"&gt;100+&lt;input type=\"number\" id=\"b\" value=\"50\"&gt; =&lt;output name=\"x\" for=\"a b\"&gt;&lt;/output&gt; &lt;/form&gt; 计算0-100的随机数加50＝多少，&lt;input type=\"range\" id=\"a\" value=\"50\"&gt;表示一个随机滚动条。77. &lt;p&gt; 段落78. &lt;param&gt; http://www.w3chtml.com/html5/tag/param.html79. &lt;pre&gt; 文本原样输出。不会改变格式80. &lt;progress&gt; 表示时间函数有关的进度条： &lt;progress&gt; &lt;span id=\"objprogress\"&gt;85&lt;/span&gt;% &lt;/progress&gt;81. &lt;q&gt; 短引用，cite属性指定来源地址，显示是会插入了一个引号，表示后面的内容是引用的内容。82. &lt;rp&gt; 指示不支持ruby元素时，显示的文本注释83. &lt;ruby&gt; 显示中文注音或者字符。里面用&lt;rt&gt;和&lt;rp&gt;元素包裹。84. &lt;s&gt; 增加删除线文本。H5不支持了。请用css，85. &lt;samp&gt; 如下标签都是不推荐使用的，请用css样式表，更好。 &lt;em&gt; 呈现为被强调的文本。 &lt;strong&gt; 定义重要的文本。 &lt;dfn&gt; 定义一个定义项目。 &lt;code&gt; 定义计算机代码文本。 &lt;samp&gt; 定义样本文本。 &lt;kbd&gt; 定义键盘文本。它表示文本是从键盘上键入的。它经常用在与计算机相关的文档或手册中。 &lt;var&gt; 定义变量。您可以将此标签与 &lt;pre&gt; 及 &lt;code&gt; 标签配合使用。 &lt;cite&gt; 定义引用。可使用该标签对参考文献的引用进行定义，比如书籍或杂志的标题。86. &lt;script&gt; javascript脚本置于其中。可链接外部ｊｓ脚本，一般脚本用于图像操作，表单验证和动态内容更改。87. &lt;select&gt; 多个option标签置于其中，形成选择下拉列表。88. &lt;small&gt; 小型文本，一般作为旁注信息89. &lt;source&gt; 多媒体资源标签： &lt;audio controls&gt; &lt;source src=\"horse.ogg\" type=\"audio/ogg\"&gt; &lt;source src=\"horse.mp3\" type=\"audio/mpeg\"&gt; Your browser does not support the audio element. &lt;/audio&gt;90 .&lt;span&gt; 对文档中行内元素进行分组。一遍对单独的一组文本进行样式控制。91 .&lt;strike&gt; 加删除线。请用del代替。不建议使用，用css吧92. &lt;strong&gt; 加粗文本93. &lt;style&gt; html插入样式信息标签。94 .&lt;sub&gt; 定义上标文本，相当于脚注信息95. &lt;summary&gt; &lt;datails&gt;元素的地一个元素，定义details的标题内容。96. &lt;sup&gt; 定义上标文本，相当于脚注信息97. &lt;table&gt; 定义表格 &lt;tr&gt;定义一行,&lt;th&gt;定义表的第一行头。&lt;td&gt;定义表的内容 &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;月份&lt;/th&gt; &lt;th&gt;存款&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;一月&lt;/td&gt; &lt;td&gt;1000 元&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;98. &lt;tbody&gt; 表格的正文部分。H５已废除99. &lt;td&gt; 表格内容行100. &lt;textarea&gt; 文本域，相当于MFC中的编辑框101. &lt;tfoot&gt; 表格的页脚部分，H5已废除102. &lt;th&gt; 表格的头一行103. &lt;thead&gt; 表格的头部分，需要有tr行104. &lt;time&gt; 定义时间或者日期，目前浏览器还都不支持105 .&lt;title&gt; 浏览器显示的标题106. &lt;tr&gt; 定义表格中的行107. &lt;track&gt; 为视频媒体文件制定外部文本轨道。比如字幕啥的。目前浏览器还不要支持此标签。 &lt;video width=\"320\" height=\"240\" controls=\"controls\"&gt; &lt;source src=\"forrest_gump.mp4\" type=\"video/mp4\" /&gt; &lt;source src=\"forrest_gump.ogg\" type=\"video/ogg\" /&gt; &lt;track kind=\"subtitles\" src=\"subs_chi.srt\" srclang=\"zh\" label=\"Chinese\"&gt; &lt;track kind=\"subtitles\" src=\"subs_eng.srt\" srclang=\"en\" label=\"English\"&gt; &lt;/video&gt;108. &lt;tt&gt; 定义打印机文本。目前h5已经不支持了。109. &lt;u&gt; 下划线。目前已不支持110. &lt;ul&gt; 无需列表。111. &lt;var&gt; 定义变量。您可以将此标签与 &lt;pre&gt; 及 &lt;code&gt; 标签配合使用。112. &lt;video&gt; 视频标签： &lt;video src=\"movie.ogg\" controls=\"controls\"&gt; 您的浏览器不支持 video 标签。 &lt;/video&gt;113. &lt;wbr&gt; 标志在何处适合加入换行符，避免有些单词加入换行符没拆开，不明意义。114. &lt;rt&gt; 在ruby元素中加入汉字的注音： &lt;ruby&gt; 漢 &lt;rt&gt; ㄏㄢˋ &lt;/rt&gt; &lt;/ruby&gt;115. &lt;section&gt; 定义区段。页眉，页脚.......116. &lt;label&gt; 定义一个选项组的标注","categories":[{"name":"html","slug":"html","permalink":"http://wedvefv.github.io/categories/html/"}],"tags":[{"name":"html5","slug":"html5","permalink":"http://wedvefv.github.io/tags/html5/"}]},{"title":"windowFTP的建立","slug":"linux/windowsFTP","date":"2016-07-31T07:30:55.000Z","updated":"2019-05-19T14:30:17.033Z","comments":true,"path":"2016/07/31/linux/windowsFTP/","link":"","permalink":"http://wedvefv.github.io/2016/07/31/linux/windowsFTP/","excerpt":"","text":"windows下建立ftp服务器需要单独建立一个用户，然后把特定目录设置为ftp目录（单独的用户需要有访问权限哦），这样避免别人知道你的计算机用户名和密码。可以把新建的这个用户名密码告诉他们。别的目录不属于这个用户的文件夹，他就没法访问了。。 运行：appwiz.cpl 添加ftp服务组件右键计算机 -管理-服务应用程序管理-IIS管理 ，添加ftp站点上传目录：一步一步设置，IP ,ftp上传目录，点口为21 ，基本，权限：可读可写，用户：所有用户，ssL可选，证书 ,完成。 下载目录：IP ，端口2121 ，用户：所有用户，SSL可选，基本，权限：可读，完成。 注意如果你使用的用户是administrator ，需要FTP上传目录和下载目录，添加用户权限，加入新建的用户。 windows下访问，可在文件浏览器输入ftp://IP 默认端口21linux下访问 ,当前目录home/username/ ,输入ftp ip port 提示输入ftp服务器的用户名和密码提示 user logged in。ls 可显示ftp上面的文件和文件夹。下载文件: get xxx ./（/home/username/）上传文件: cd 进入到ftp的目录11/ cd 11 然后 put home/username/index.php ,就把index.php上传了。。","categories":[{"name":"windows","slug":"windows","permalink":"http://wedvefv.github.io/categories/windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://wedvefv.github.io/tags/windows/"}]},{"title":"LinuxFTP的建立","slug":"linux/LinuxFTP","date":"2016-07-31T03:30:55.000Z","updated":"2019-03-02T10:16:37.991Z","comments":true,"path":"2016/07/31/linux/LinuxFTP/","link":"","permalink":"http://wedvefv.github.io/2016/07/31/linux/LinuxFTP/","excerpt":"","text":"linux FTP建立，条件：安装vsftpd：配置vsftpd的配置文件：vim /etc/vsftpd.conf anonymous_enbale =NO //关闭匿名登录local_enbale=YES //允许本地用户，就是ftp建立者的用户名和密码write_enbale=YES //允许写入，就是上传文件到ftp 反注释掉：ascii_upload_enbale=YESascii_download_enbale=YES 默认的ftp目录就是home下的user目录，包含桌面，下载等等文件夹。","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[]},{"title":"非对称加密(公钥加密)","slug":"linux/public_key_encryption","date":"2016-07-21T06:35:58.000Z","updated":"2019-05-19T14:30:17.033Z","comments":true,"path":"2016/07/21/linux/public_key_encryption/","link":"","permalink":"http://wedvefv.github.io/2016/07/21/linux/public_key_encryption/","excerpt":"","text":"公钥加密的工作原理 对称加密：1* 加密密钥和解密密钥是一样的。 非对称加密：12* (也叫公钥加密)* 两个密钥在加密和解密中配合使用，密钥对具有特殊的互补关系，密钥对在数学上存在特殊关系。 邮件的电子签名过程： 12* 捕获邮件正文--&gt;计算邮件哈希值--&gt;检索发件人私钥--&gt;用发件人私钥加密哈希值--&gt;附加到邮件底部(明文签名)/与原始邮件组合成二进制附件(不透明签名)--&gt;发送mail* --私钥只有发件人才唯一拥有，公钥仅仅与一个私钥关联，所以可以用公钥唯一识别一个私钥。 验证邮件签名的过程：1234* 接收邮件--&gt;检索加密的哈希值--&gt;检索邮件正文--&gt;用正文计算邮件哈希值--&gt;检索发件人的公钥--&gt;用发件人公钥解密签名(加密的哈希值)--&gt;和计算的哈希值对比--&gt;验证签名邮件* --文件内容不变，计算的哈希值就不会变。* --私钥加密的东西，需要对应的公钥解密。* --如果哈希值一致，说明公钥对应的私钥是对的，私钥只有发件人知道，所以确定发件人属实。 邮件内容的加密123* 对称密钥加密的话，需要\"密钥协商\"，必须协商出一个双方都知道的密钥。* 非对称密钥加密的话，没有协商过程，因为一个公钥，可以很多人拥有，私钥是只有一个人有。* 由于非对称(公钥加密)密钥加密使用密钥对，加密和解密是一个昂贵的计算过程，速度慢。所以这么做呗...... send加密mail内容1* -- 1.找到邮件正文--&gt;2.检索收件人公钥--&gt;3.生成一次性的会话密钥(这个是对称密钥)--&gt;4.用会话密钥加密正文--&gt;5.用收件人公钥加密会话密钥，并附到邮件--&gt;6.发送邮件 recv解密mail内容1* -- 1.接收邮件--&gt;2.检索加密邮件正文和会话密钥-&gt;3.检索收件人私钥解密会话密钥-&gt;4.用解密的会话密钥解密正文-&gt;5.解密邮件返回给收件人 同时使用签名和邮件内容加密 同时使用签名和邮件内容加密后的解密 功能和所需的密钥表","categories":[{"name":"windows","slug":"windows","permalink":"http://wedvefv.github.io/categories/windows/"}],"tags":[{"name":"encrypt","slug":"encrypt","permalink":"http://wedvefv.github.io/tags/encrypt/"}]},{"title":"windows时间的处理","slug":"linux/win_time_func","date":"2016-06-28T06:33:59.000Z","updated":"2019-05-19T14:30:17.033Z","comments":true,"path":"2016/06/28/linux/win_time_func/","link":"","permalink":"http://wedvefv.github.io/2016/06/28/linux/win_time_func/","excerpt":"","text":"windows时间的处理：系统时间： UTC时间（格林威治时间）,世界标准时间，北京时间是UTC+8 本地时间： UTC时间+时区偏差，就是计算机右下角显示的时间 文件时间：类型有三种 1.创建时间 2.访问时间 3.修改时间 文件时间是： 64位的值记录了自1601年1月1日0点以来的以100纳秒（ns）为单位的格林威治时间间隔，我们鼠标右键查看文件属性，看到的是这个间隔加上时区差的，并且显示格式的SYSTEM结构体形式(年月日的形式)，不是FILETIME结构体形式（两个DWORD成员）。所以看起来跟本地时间差别不大。 基本概念先来看看这两个结构体的定义： FILETIME结构体:1234typedef struct _FILETIME &#123; DWORDdwLowDateTime; DWORDdwHighDateTime;&#125; FILETIME, *PFILETIME, *LPFILETIME; 它在MSDN上的说明——Contains a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC时间). SYSTEMTIME结构体：12345678910111213141516171819typedef struct _SYSTEMTIME &#123; WORDwYear; WORDwMonth; WORDwDayOfWeek; WORDwDay; WORDwHour; WORDwMinute; WORDwSecond; WORDwMilliseconds;&#125; SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME; 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include \"stdafx.h\"#include &lt;windows.h&gt; #include &lt;stdio.h&gt; //#include &lt;conio.h&gt; class CLocaltimeAndFiletime &#123; public: static void GetCurrentLocalTime(char *pstrDate, char *pstrTime); static void FileTimeToLocalTime(FILETIME &amp;ft, char *pstrDate, char *pstrTime); &#125;; //取得：本地时间 = UTC+8（北京的） //UTC是系统时间void CLocaltimeAndFiletime::GetCurrentLocalTime(char *pstrDate, char *pstrTime) &#123; SYSTEMTIME st; GetLocalTime(&amp;st); //取得本地时间 //getsystemtime(&amp;st) //依据所在时区，和本地时间，推算出UTC时间=本地-8小时 if (pstrDate != NULL) sprintf(pstrDate, \"%d-%d-%d\", st.wYear, st.wMonth, st.wDay); if (pstrTime != NULL) sprintf(pstrTime, \"%02d:%02d:%02d\", st.wHour, st.wMinute, st.wSecond); &#125; //把一个64e位的文件时间（三种类型，创建/访问/修改），转换成SYSTEEMTIME结构类型void CLocaltimeAndFiletime::FileTimeToLocalTime(FILETIME &amp;ft, char *pstrDate, char *pstrTime) &#123; FILETIME localft; //文件时间是1601年--目前的UTC时间的差（64位整数），转换成UTC+本地时区的64位值， FileTimeToLocalFileTime(&amp;ft, &amp;localft); SYSTEMTIME st; FileTimeToSystemTime(&amp;localft, &amp;st); //转换成年月日形式 if (pstrDate != NULL) sprintf(pstrDate, \"%d-%d-%d\", st.wYear, st.wMonth, st.wDay); if (pstrTime != NULL) sprintf(pstrTime, \"%02d:%02d:%02d\", st.wHour, st.wMinute, st.wSecond); &#125; int main(int argc, char *argv[]) &#123; printf(\"windows(FILETIME和SYSTEMTIME) \\n\"); const int MAX_LEN = 30; char strDate[MAX_LEN], strTime[MAX_LEN]; CLocaltimeAndFiletime::GetCurrentLocalTime(strDate, strTime); printf(\"current: %s %s\\n\", strDate, strTime); const char* pstrFileName = \"C:\\\\1.html\"; printf(\"文件名：%s\\n\", pstrFileName); //打开一个文件取得句柄，利用这个句柄取得文件的时间属性（创建，访问，修改） HANDLE handleFile = CreateFile(pstrFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL); FILETIME ftCreationTime, ftLastAccessTime, ftLastWriteTime; //取得时间属性 GetFileTime(handleFile, &amp;ftCreationTime, &amp;ftLastAccessTime, &amp;ftLastWriteTime); //转换创建时间 CLocaltimeAndFiletime::FileTimeToLocalTime(ftCreationTime, strDate, strTime); printf(\"create: %s %s\\n\", strDate, strTime); //转换最后一次访问时间 CLocaltimeAndFiletime::FileTimeToLocalTime(ftLastAccessTime, strDate, strTime); printf(\"access: %s %s\\n\", strDate, strTime); //转换修改时间 CLocaltimeAndFiletime::FileTimeToLocalTime(ftLastWriteTime, strDate, strTime); printf(\"modify: %s %s\\n\", strDate, strTime); //getch(); return 0; &#125;","categories":[{"name":"windows","slug":"windows","permalink":"http://wedvefv.github.io/categories/windows/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://wedvefv.github.io/tags/c/"}]},{"title":"git 配置文件","slug":"linux/git_1_config","date":"2016-06-28T06:33:58.000Z","updated":"2019-05-19T14:18:38.607Z","comments":true,"path":"2016/06/28/linux/git_1_config/","link":"","permalink":"http://wedvefv.github.io/2016/06/28/linux/git_1_config/","excerpt":"","text":"基于公司是代理上网的，所以配置windows下的.gitconfig文件如下：1234567[http] proxy = 代理ip:代理port[user] email = xxxxx@gmail.com name =xxxxxhhh [gui] encoding = utf-8 #代码库统一使用utf-8 由于本人电脑是日语版OS，所以GIT终端显示中文字体是乱码，所以索性设置全部使用utf-8编码。","categories":[{"name":"git","slug":"git","permalink":"http://wedvefv.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://wedvefv.github.io/tags/git/"}]}]}