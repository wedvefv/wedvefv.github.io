{"meta":{"title":"小莺の博客","subtitle":"记录学习的技能和遇到的问题","description":"做自己爱做的事，爱自己在做的事！","author":"wedvefv","url":"http://wedvefv.github.io"},"pages":[{"title":"about","date":"2018-05-01T09:10:48.000Z","updated":"2018-05-26T02:38:14.922Z","comments":true,"path":"about/index.html","permalink":"http://wedvefv.github.io/about/index.html","excerpt":"","text":"Welcome to rlovep! This is my bolg;weibo for more info. If you get any problems when see this page, you can find the answer in csdn or you can ask me on GitHub. ##"}],"posts":[{"title":"centos编译安装opensty","slug":"lua/2018-10-07_openresty","date":"2018-10-07T03:23:58.000Z","updated":"2019-01-26T05:00:29.042Z","comments":true,"path":"2018/10/07/lua/2018-10-07_openresty/","link":"","permalink":"http://wedvefv.github.io/2018/10/07/lua/2018-10-07_openresty/","excerpt":"","text":"安装依赖包1yum install -y make cmake gcc gcc-c++ autoconf automake libpng-devel libjpeg-devel zlib libxml2-devel ncurses-devel bison libtool-ltdl-devel libiconv libmcrypt mhash mcrypt pcre-devel openssl-devel freetype-devel libcurl-devel readline-devel curl 解释","categories":[{"name":"lua","slug":"lua","permalink":"http://wedvefv.github.io/categories/lua/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://wedvefv.github.io/tags/hexo/"}]},{"title":"最小化安装centos7配置问题","slug":"linux/2018-10-05_linux","date":"2018-10-05T02:34:58.000Z","updated":"2018-10-05T04:31:35.927Z","comments":true,"path":"2018/10/05/linux/2018-10-05_linux/","link":"","permalink":"http://wedvefv.github.io/2018/10/05/linux/2018-10-05_linux/","excerpt":"","text":"最小化安装启用网卡1234vi /etc/sysconfig/network-scripts/ifcfg-[网卡]修改 ONBOOT=yesservice network restart ip 命令替代了config, 常见用法123456789101112131415161718192021222324252627ip link show # 显示网络接口信息ip link set eth0 upi # 开启网卡ip link set eth0 down # 关闭网卡ip link set eth0 promisc on # 开启网卡的混合模式ip link set eth0 promisc offi # 关闭网卡的混个模式ip link set eth0 txqueuelen 1200 # 设置网卡队列长度ip link set eth0 mtu 1400 # 设置网卡最大传输单元ip addr show # 显示网卡IP信息ip addr add 192.168.0.1/24 dev eth0 # 设置eth0网卡IP地址192.168.0.1ip addr del 192.168.0.1/24 dev eth0 # 删除eth0网卡IP地址ip route list # 查看路由信息ip route add 192.168.4.0/24 via 192.168.0.254 dev eth0 # 设置192.168.4.0网段的网关为192.168.0.254,数据走eth0接口ip route add default via 192.168.0.254 dev eth0 # 设置默认网关为192.168.0.254 英文环境的mac远程centos虚拟机乱码原因分析 mac默认是 12LANG=en_US.utf-8 // 设置区域语言，比如提示信息，日期等等LC_ALL=en_US.utf-8 远程虚拟机最小化安装 echo $LANG linux 配置问价加载顺序是12默认登陆方式，/etc/enviroment-&gt;/etc/profile --&gt;$HOME/.profile --&gt;$HOME/.env /etc/profile是登陆后读取的，如果文件显示乱码，可以在/etc/profile中配置 12vim /etc/profileexport LC_ALL=zh_CN.utf-8 如果ssh远程出现如下问题 “-bash: 警告:setlocale: LC_CTYPE: 无法改变区域选项 (UTF-8): 没有那个文件或目录” 是加载/etc/enviroment文件,找LANG变量 123vim /etc/environmentLANG=zh_CN.utf-8如果/etc/environment 中没有设置该变量LANG，依然会报错，不能在profile中设置","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://wedvefv.github.io/tags/hexo/"}]},{"title":"centos6.4 升级python到2.7","slug":"linux/centos6.4升级python","date":"2018-06-30T02:15:00.000Z","updated":"2018-06-30T03:23:21.252Z","comments":true,"path":"2018/06/30/linux/centos6.4升级python/","link":"","permalink":"http://wedvefv.github.io/2018/06/30/linux/centos6.4升级python/","excerpt":"","text":"1. download source1wget https://www.python.org/ftp/python/2.7.12/Python-2.7.12.tgz 2. compire and install1234tar zxvf Python-2.7.12.tgzcd Python-2.7.12./configure --prefix=/usr/local/python27 &amp;&amp; make &amp;&amp; make install &amp;&amp; echo $?如果以上输出为0，说明没有报错，安装正常 3. add path and backup the python2.61234567移除以前的版本mv /usr/bin/python /usr/bin/python26创建软连接ln -s /usr/local/python27/bin/python /usr/bin/python查看版本是否升级成功python -VPython 2.7.12 4. modify yum1234如果不修改此项，会导致yum无法使用vim /usr/bin/yum修改第一行即可，将环境变量指向以前的python版本#!/usr/bin/python26 5. reinstall pip12345678910111213141516171819202122232425262728291.安装pip之前首先需要安装setuptools下载链接https://pypi.python.org/pypi/setuptools下载地址wget https://pypi.python.org/packages/ff/d4/209f4939c49e31f5524fa0027bf1c8ec3107abaf7c61fdaad704a648c281/setuptools-21.0.0.tar.gz#md5=81964fdb89534118707742e6d1a1ddb4 --no-check-certificate解压tar zxvf setuptools-21.0.0.tar.gz安装cd setuptools-21.0.0python setup.py install2.安装pip下载链接https://pypi.python.org/pypi/pip下载地址wget https://pypi.python.org/packages/41/27/9a8d24e1b55bd8c85e4d022da2922cb206f183e2d18fee4e320c9547e751/pip-8.1.1.tar.gz#md5=6b86f11841e89c8241d689956ba99ed7 --no-check-certificate解压tar zxvf pip-8.1.1.tar.gz 安装 cd pip-8.1.1python setup.py install3.添加环境变量安装完之后，之后执行pip还是调用的以前的环境变量，需要手动添加环境变量mv /usr/bin/pip /usr/bin/pip26ln -s /usr/local/python27/bin/pip /usr/bin/再次查看版本pip -Vpip 8.1.1 from /usr/local/python27/lib/python2.7/site-packages/pip-8.1.1-py2.7.egg (python 2.7) 6.使用pip安装第三方库1234567891011121314151617181920如果报错locale.Error: unsupported locale setting加入环境变量：export LANGUAGE=en_US.UTF-8export LC_ALL=en_US.UTF-8pip install psutilpip install MySQLdb-pythonpip install django=1.8.2报错： pip install MySQLdb-pythonCollecting MySQLdb-python Retrying (Retry(total=4, connect=None, read=None, redirect=None)) after connection broken by 'ReadTimeoutError(\"HTTPSConnectionPool(host='pypi.python.org', port=443): Read timed out. (read timeout=15)\",)': /simple/mysqldb-python/ Could not find a version that satisfies the requirement MySQLdb-python (from versions: )No matching distribution found for MySQLdb-pythonYou are using pip version 8.1.1, however version 9.0.1 is available.You should consider upgrading via the 'pip install --upgrade pip' command.当安装中提示版本太低的时候，执行提示的命令进行升级即可pip install --upgrade pip升级完重新执行要安装的库","categories":[],"tags":[]},{"title":"centos6.4 安装python mysql扩展","slug":"linux/centos6.4install-mysql-python","date":"2018-06-30T02:15:00.000Z","updated":"2019-01-26T04:59:59.657Z","comments":true,"path":"2018/06/30/linux/centos6.4install-mysql-python/","link":"","permalink":"http://wedvefv.github.io/2018/06/30/linux/centos6.4install-mysql-python/","excerpt":"","text":"要想使python可以操作mysql 就需要MySQL-python驱动，它是python 操作mysql必不可少的模块。 下载地址：https://pypi.python.org/pypi/MySQL-python/ 下载MySQL-python-1.2.5.zip 文件之后直接解压。进入MySQL-python-1.2.5目录: python setup.py install 报错： [root@centos7 MySQL-python-1.2.4]# python setup.py install sh: mysql_config: command not found Traceback (most recent call last): File “setup.py”, line 18, in metadata, options = get_config() File “/root/MySQL-python-1.2.4/setup_posix.py”, line 43, in get_config libs = mysql_config(&quot;libs_r&quot;) File “/root/MySQL-python-1.2.4/setup_posix.py”, line 25, in mysql_config raise EnvironmentError(&quot;%s not found&quot; % (mysql_config.path,)) EnvironmentError: mysql_config not found 网上查了一下需安装mysql-devel #yum -y install mysql-devel 安装成功后 python setup.py install安装成功。","categories":[{"name":"c","slug":"c","permalink":"http://wedvefv.github.io/categories/c/"}],"tags":[]},{"title":"git 常见操作","slug":"git/git_2_operate","date":"2018-05-26T04:00:00.000Z","updated":"2018-05-26T04:25:50.312Z","comments":true,"path":"2018/05/26/git/git_2_operate/","link":"","permalink":"http://wedvefv.github.io/2018/05/26/git/git_2_operate/","excerpt":"","text":"创建分支1git branch new_branch 本地删除分支1git branch -D delete_branch 更新到远程删除分支12git checkout master git pull -u -u origin :delete_branch git pull 失败提示fatal: refusing to merge unrelated histories ,处理方法1git pull origin master --allow-unrelated-historiesn 查看提交提记录12345git loggit log -p -2 #查看最近两次的提交差异git log --stat #仅仅现实行数的变更git log --pretty=oneline #每次提交，在一行显示git log --pretty=format:\"%h - %an, %ar : %s\" #格式显示 选项 说明 %H 提交对象（提交）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（树）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（父）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（作者）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用-date =选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者（提交者）的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 待续……","categories":[{"name":"git","slug":"git","permalink":"http://wedvefv.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://wedvefv.github.io/tags/git/"}]},{"title":"windows 管道通信","slug":"windows/windows_pipe","date":"2017-01-08T06:11:00.000Z","updated":"2018-05-26T02:38:14.916Z","comments":true,"path":"2017/01/08/windows/windows_pipe/","link":"","permalink":"http://wedvefv.github.io/2017/01/08/windows/windows_pipe/","excerpt":"","text":"#windows 管道通信 思路如下：server端：1 建立一个可读可写的管道2 将cmd /c+命令建立的执行进程的输出（stdOutput）和错误(stdError)与管道写端关联。就是把cmd执行命令的结果写进管道。3 recv client端发来的命令比如： “dir”4 组合成字符串”c:/windows/system32/cmd.exe /cdir”5 利用字符串建立进程，就是执行的意思6 sleep(1000) 停止一秒，让进程完全执行完输出结果否则可能进程没执行完毕，就向下执行了，导致管道中只有部分cmd命令执行的结果。7 while循环ReadFile读取管道中的数据8 send发送数据给client端，显示 client端：这个很简单，建立一个阻塞的socket ，循环发送你想法的命令，到server端执行就可以了。 server端代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//server.cpp #include \"stdafx.h\"#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#pragma comment(lib, \"ws2_32.lib\")int main(int argc, char* argv[])&#123; SOCKET sClient; BYTE minorVer = 2; BYTE majorVer = 2; WSADATA wsaData; WORD sockVersion = MAKEWORD(minorVer, majorVer); if(WSAStartup(sockVersion, &amp;wsaData) != 0) return 0; SOCKET sListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(sListen == INVALID_SOCKET) &#123; printf(\"socket error \\n\"); return 0; &#125; sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(4500); sin.sin_addr.S_un.S_addr = INADDR_ANY; if(bind(sListen, (LPSOCKADDR)&amp;sin, sizeof(sin)) == SOCKET_ERROR) &#123; printf(\"bind error \\n\"); return 0; &#125; if(listen(sListen, 5) == SOCKET_ERROR) &#123; printf(\"listen error \\n\"); return 0; &#125; sClient =accept(sListen,NULL,NULL);// send(sClient,wMessage,strlen(wMessage),0); char rBuffer[4096] = &#123;0&#125;; char totalbuffer[4096] =&#123;0&#125;; char cmdline[256]=&#123;0&#125;; while(true) &#123; memset(cmdline,0,256); SECURITY_ATTRIBUTES sa; HANDLE hRead,hWrite; sa.nLength = sizeof(SECURITY_ATTRIBUTES); sa.lpSecurityDescriptor = NULL; sa.bInheritHandle = TRUE; if (!CreatePipe(&amp;hRead,&amp;hWrite,&amp;sa,0)) &#123; printf(\"CreatePipe Error\"); return 0; &#125; STARTUPINFO si; PROCESS_INFORMATION pi; si.cb = sizeof(STARTUPINFO); GetStartupInfo(&amp;si); si.hStdError = hWrite; si.hStdOutput = hWrite; si.wShowWindow = SW_HIDE; si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; GetSystemDirectory(cmdline,sizeof(cmdline)); strcat(cmdline,\"\\\\cmd.exe /c\"); char cmdbuff[256]; ZeroMemory(cmdbuff,sizeof(cmdbuff)); recv(sClient,cmdbuff,256,NULL); strncat(cmdline,cmdbuff,strlen(cmdbuff)); if (!CreateProcess(NULL,cmdline,NULL,NULL,TRUE,NULL,NULL,NULL,&amp;si,&amp;pi)) &#123; printf(\"CreateProcess Error\"); continue; &#125; ZeroMemory(cmdbuff,sizeof(cmdbuff)); CloseHandle(hWrite); DWORD dwRead; Sleep(1000); while(ReadFile(hRead,rBuffer,4096,&amp;dwRead,NULL)) &#123; char a[4] =&#123;0&#125;; sprintf(a,\"%d\",dwRead); //把数字转换成字符串放入数组 lstrcpy(totalbuffer,a); // 把总字节数写入数据最前面 lstrcat(totalbuffer,\"#\");//在加一个#符表示数字部分结束 lstrcat(totalbuffer,rBuffer);//缀数据部分 printf(\"%d\",dwRead); send(sClient,totalbuffer,dwRead+5,0); //发送 printf(\"%s\",totalbuffer); memset(rBuffer,0,4096); // 这是个死循环，一直读取管道中数据，所有要清零缓存 memset(totalbuffer,0,4096); &#125; &#125; return 0;&#125; client端代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include \"stdafx.h\"#include &lt;Winsock2.h&gt;#pragma comment(lib,\"ws2_32.lib\")int main(int argc, char* argv[])&#123; BYTE minorVer = 2; BYTE majorVer = 2; char recvBuf[4096]=&#123;0&#125;; char buffer[4096]=&#123;0&#125;; char temp[10]=&#123;0&#125;; int len = 0; int total = 0; int t =0; WSADATA wsaData; WORD sockVersion = MAKEWORD(minorVer, majorVer); if(WSAStartup(sockVersion, &amp;wsaData) != 0) return 0; //创建套接字 SOCKET sockClient = socket( AF_INET,SOCK_STREAM, 0 ); SOCKADDR_IN addrSrv; addrSrv.sin_addr.S_un.S_addr = inet_addr(\"172.28.125.137\"); //存server端ip ， addrSrv.sin_family = AF_INET; addrSrv.sin_port = htons(4500); char x[15]=&#123;0&#125;; //存放命令比如： cd ， dir ，ls ，pwd //向服务器发出连接请求 connect( sockClient, (SOCKADDR*)&amp;addrSrv, sizeof(SOCKADDR)); // 连接 while(1)&#123; ZeroMemory(recvBuf,sizeof(recvBuf)); // 清零缓存 if(0!=scanf(\"%s\",x))&#123; // 等待输入命令 send(sockClient,x,lstrlen(x), 0 ); total=recv( sockClient, buffer, 4096, 0 ); //接收一次，可能收不完哦 lstrcat(recvBuf,buffer); // 存到总buffer里面 memcpy(temp,buffer,strstr(buffer,\"#\")-buffer);// 从buffer里面取出来数字部分，就是#前的字符串 t = atoi(temp); // 转成数字 printf(\"%d\",t); while(total&lt;t)&#123; //如果第一次收到的小于这个数字，继续接收，存到临时buffer ZeroMemory(buffer,sizeof(buffer)); len=recv( sockClient, buffer, 4096, 0 ); total=len+total; // 取到的长度加上第一次的长度 lstrcat(recvBuf,buffer);// 这次取得放到总的recvBuf里面 &#125; // printf(\"%d\\n\",atoi(recvBuf)); printf(\"%s\\n\",recvBuf); printf(\"%d\\n\",strlen(recvBuf)); total =0; // 以下清零是为了下次while循环准备， len = 0; t =0; ZeroMemory(temp,sizeof(temp)); ZeroMemory(buffer,sizeof(buffer)); ZeroMemory(recvBuf,sizeof(recvBuf)); &#125; //接受数据 &#125; closesocket(sockClient); WSACleanup(); return 0;&#125; 注意：ReadFile是异步或同步模式 ，ReadFileEx只有异步模式","categories":[{"name":"windows","slug":"windows","permalink":"http://wedvefv.github.io/categories/windows/"}],"tags":[]},{"title":"unix获取时间的小程序","slug":"c/unix_netcode","date":"2017-01-07T07:30:30.000Z","updated":"2019-01-26T04:58:36.574Z","comments":true,"path":"2017/01/07/c/unix_netcode/","link":"","permalink":"http://wedvefv.github.io/2017/01/07/c/unix_netcode/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//一个简单的时间获取客户程序#include &lt;netinet/in.h&gt; /* sockaddr_in&#123;&#125; and other Internet defns */#include &lt;strings.h&gt;#include &lt;stdarg.h&gt; /* ANSI C header file */#include &lt;syslog.h&gt; /* for syslog() */#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#define MAXLINE 4096 /* max text line length */#define SA struct sockaddrvoid err_doit(int errnoflag, const char *fmt, va_list ap)&#123; int errno_save; char buf[MAXLINE]; errno_save = errno; /* value caller might want printed */ vsprintf(buf, fmt, ap); if (errnoflag) sprintf(buf + strlen(buf), \": %s\", strerror(errno_save)); strcat(buf, \"\\n\"); fflush(stdout); /* in case stdout and stderr are the same */ fputs(buf, stderr); fflush(stderr); /* SunOS 4.1.* doesn't grok NULL argument */ return;&#125;void err_quit(const char *fmt, ...)&#123; va_list ap; va_start(ap, fmt); err_doit(0, fmt, ap); va_end(ap); exit(1);&#125;void err_sys(const char *fmt, ...)&#123; va_list ap; va_start(ap, fmt); err_doit(1, fmt, ap); va_end(ap); exit(1);&#125;int main(int argc, char **argv)&#123; int sockfd, n; char recvline[MAXLINE + 1]; struct sockaddr_in servaddr; if (argc != 2) err_quit(\"usage: a.out &lt;IPaddress&gt;\"); if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) err_sys(\"socket error\"); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(13); /* daytime server */ if (inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0) err_quit(\"inet_pton error for %s\", argv[1]); if (connect(sockfd, (SA *) &amp; servaddr, sizeof(servaddr)) &lt; 0) err_sys(\"connect error\"); while ((n = read(sockfd, recvline, MAXLINE)) &gt; 0) &#123; recvline[n] = 0; /* null terminate */ if (fputs(recvline, stdout) == EOF) err_sys(\"fputs error\"); &#125; if (n &lt; 0) err_sys(\"read error\"); exit(0);&#125;","categories":[{"name":"c","slug":"c","permalink":"http://wedvefv.github.io/categories/c/"}],"tags":[]},{"title":"apache_wsgi支持python脚本","slug":"linux/apache_wsgi","date":"2017-01-07T06:00:00.000Z","updated":"2019-01-26T04:59:17.452Z","comments":true,"path":"2017/01/07/linux/apache_wsgi/","link":"","permalink":"http://wedvefv.github.io/2017/01/07/linux/apache_wsgi/","excerpt":"","text":"apache支持python脚本配置httpd.conf追加：1234567891011LoadModule wsgi_module modules/mod_wsgi.so WSGIScriptAlias / C:/xampp/www/py/myweb/myweb/wsgi.py WSGIPythonPath C:/xampp/www/py/myweb #django 项目目录DocumentRoot \"C:/xampp/www/py/myweb/myweb\" #具体应用目录&lt;Directory \"C:/xampp/www\"&gt;Options Indexes FollowSymLinks Includes ExecCGIAllowOverride AllRequire all granted&lt;/Directory&gt; Options Indexes FollowSymLinks Includes ExecCGI禁止显示Apache目录列表-Indexes FollowSymLinks如何修改目录的配置以禁止显示 Apache 目录列表。减号和去掉indexes是一样的效果 ，都是不存在index时，不要显示目录结构，安全起见。xampp 中的不带减号，依然不可以访问目录。目前不知道原因。可能做了某些安全设置。 AllowOverride参数就是指明Apache服务器是否去找.htacess文件作为配置文件，如果设置为none,那么服务器将忽略.htacess文件，如果设置为All,那么所有在.htaccess文件里有的指令都将被重写。 Require all granted 允许所有请求访问资源","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[]},{"title":"nginx  support  php","slug":"linux/nginx_config","date":"2016-12-10T03:30:55.000Z","updated":"2019-01-26T05:00:12.396Z","comments":true,"path":"2016/12/10/linux/nginx_config/","link":"","permalink":"http://wedvefv.github.io/2016/12/10/linux/nginx_config/","excerpt":"","text":"ubuntu14.04 +nginx+php5-fpm一，安装Nginx apt-get install nginx 1，配置nginx nginx所有的配置在 /etc/nginx/nginx.conf中 nginx.conf配置里面包括了 include /etc/nginx/conf.d/.conf; include /etc/nginx/sites-enabled/; 这两个配置，所以这里面的配置也是有效的。 错误日志 error_log /var/log/nginx/error.log; 这里我们把配置写在 /etc/nginx/sites-available/default中 修改 root /usr/share/nginx/html; 这是网页的根目录，默认里面有一个index.html页面 index index.html index.htm修改成index index.php index.html index.htm; 增加 location ~ .php$ { try_files $uri =404; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params; } 2，保存文件，使配置生效 /etc/init.d/nginx reload 3，启动nginx /etc/init.d/nginx start 4，在 /usr/share/nginx/html下新建index.php &lt;? php phpinfo(); ?&gt; 二 安装phpsudo apt-get install php5-fpm sudo apt-get install php5-gd # Popular image manipulation library; used extensively by Wordpress and it’s plugins.sudo apt-get install php5-cli # Makes the php5 command available to the terminal for php5 scriptingsudo apt-get install php5-curl # Allows curl (file downloading tool) to be called from PHP5sudo apt-get install php5-mcrypt # Provides encryption algorithms to PHP scriptssudo apt-get install php5-mysql # Allows PHP5 scripts to talk to a MySQL Databasesudo apt-get install php5-readline # Allows PHP5 scripts to use the readline function 查看php5运行进程 ps -waux | grep php5 打开关闭php5进程 sudo service php5-fpm stopsudo service php5-fpm startsudo service php5-fpm restartsudo service php5-fpm status 配置php5监听端口 /etc/php5/fpm/pool.d/www.conf 把 listen = /var/run/php5-fpm.sock 改为 listen = 127.0.0.1:9000 重新运行php进程","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[]},{"title":"vim-markdown插件","slug":"vim/vim-markdown","date":"2016-10-27T07:30:00.000Z","updated":"2018-05-26T02:38:14.916Z","comments":true,"path":"2016/10/27/vim/vim-markdown/","link":"","permalink":"http://wedvefv.github.io/2016/10/27/vim/vim-markdown/","excerpt":"","text":"首先为了高亮显示markdown文件 ，安装vim-markdown插件(vundle管理的)12Plugin 'godlygeek/tabular'Plugin 'tpope/vim-markdown' 安装时时预览插件 只支持macos/linux ,打开markdown文件就会出现浏览器窗口预览1\"Plugin 'suan/vim-instant-markdown' #windows 下有一个python2支持的插件，也能预览 需要python2的支持–python2.7就可以。需要nodejs的支持，自行安装。完成后： 1npm -g install instant-markdown-d 在vim配置文件中添加: 1Plugin 'suan/vim-instant-markdown' 打开vim 更新安装插件 ： 1:PluginInstall","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"http://wedvefv.github.io/tags/vim/"}]},{"title":"vim-emmet插件/html/css","slug":"vim/vim-emmet","date":"2016-10-26T16:00:00.000Z","updated":"2018-10-20T16:45:10.953Z","comments":true,"path":"2016/10/27/vim/vim-emmet/","link":"","permalink":"http://wedvefv.github.io/2016/10/27/vim/vim-emmet/","excerpt":"","text":"emmet-vim 插件就是以前的zencoding安装 可以git clone ，可以在vim里面安装PluginInstall 来说一下快捷键快捷键一： 输入html：5 按下ctrl+y 松开后在按逗号（英文的哦）立刻展开成如下了12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; html:xt 就是兼容的html版本 快捷键二：div#page&gt;div.logo+ul#navigation2&gt;li5&gt;a也是ctrl+y，松开后按英文逗号，展开后是：1234567891011121314151617&lt;div id=\"page\"&gt; &lt;div class=\"logo\"&gt;&lt;/div&gt; &lt;ul id=\"navigation\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"navigation\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 可以看出来： #号是表示id.表示class+ 表示同一级的元素可以用*n 产生多个同名同级的元素>表示要包含的元素#xxx 默认的这个表示默认div元素，且id为xxx","categories":[{"name":"vim","slug":"vim","permalink":"http://wedvefv.github.io/categories/vim/"}],"tags":[]},{"title":"vim 乱码","slug":"vim/vim_luanma","date":"2016-10-26T10:37:00.000Z","updated":"2018-05-26T02:38:14.914Z","comments":true,"path":"2016/10/26/vim/vim_luanma/","link":"","permalink":"http://wedvefv.github.io/2016/10/26/vim/vim_luanma/","excerpt":"","text":"首先 中文os下，我们一般的设置是：123456set encoding=utf-8 \"设置gvim内部编码set fileencoding=utf-8 \"设置当前文件编码set fileencodings=gbk,utf-8,shift_jis,ucs-bom,latin1,gb2312,cp936,cp932 设置支持打开的文件的编码set termencoding=utf-8set guifont=DejaVu\\\\ Sans\\\\ Mono\\\\:h13 上述，set fileencodings设置的文字编码解析顺位，对于中文是可以解析出来的,shift_jis编码的文件，就会出现乱码。除非你把shift_jis设置第一位： 1set fileencodings=shift_jis,gbk,utf-8,ucs-bom,latin1,gb2312,cp936,cp932 对于日文os ，安装gvim后，需要如下设置：由于本地ANSI是cp932 , 所以把cp932 放在第一或者第二的位置，如果放到第三或者后面就会出现shift_jis编码的日文打开后是文本乱码现象。 123456789set encoding=utf-8 \"设置gvim内部编码set fileencoding=utf-8 \"设置当前文件编码set fileencodings=CP932,utf-8,gbk,,ucs-bom,latin1,gb2312,cp936 #设置支持打开的文件的编码set termencoding=utf-8set guifont=DejaVu\\ Sans\\ Mono\\:h13 set guifontwide=NSimsun\\:h14 #设置新宋体 由于DejaVu Sans Mono 字体是英文字符字体，无法正确显示宽字体，所以需要特别加入12set guifontwide=NSimsun\\:h14 #设置新宋体 ，显示汉字 所以大家在自己的sublime 或者vim中设置编辑器字体DejaVu Sans Mono就好像可以显示正确的汉字和英文，其实我们设置的只是英文字符显示的样式。汉字其实是系统本地ANSI编码。 本地ANSI编码世界上每种语言对应的windows 系统都有各自的ANSI，互相不兼容。 比如 中文ANSI == GBK(中文) ，gbk是gb2312(简体中文)的扩展，包含繁体，日文片假名。cp936就是gbk 日文ANSI == Windows-31J 就是cp932.shift_jis也是一种日文字符编码,不过，只实现了cp932的部分，所以cp932编码的东东，shift_jis可能乱码。shift_jis编码的，cp932一定正常显示。 这是微软早起应对不同国家一种混合的编码：字母+对应的国家文字,这种字符也是多字节字符。比如：中文ANSI,字母数字是1字节 ,汉字是2字节。两种语言文字有可能在一起就显示乱码。不过微软提供了本地ANSI转换为标准unicode字符的方案，通过代码页转换表技术这一过度方案。 nnicode编码规范unicode 是将全世界所有的字符都统一编码的方案(规范))。那么字符a的编码本来是1byte ,现在统一和一个汉字一样长了。那么问题来了，字符串是’\\0’字符结尾。世界上的很久以前写的c程序，就没办法用了。所以说unicode应该早点出来。 有了这种全字符集，解决了乱码，却没法用，蛋疼吧，可是utf8这一实现字符保存，传输的方案出现了。因为utf8是可变长的。不同位段，长度不一致。 utf-8编码12345678910UCS-2编码(16进制) UTF-8 字节流(二进制)0000 - 007F 0xxxxxxx0080 - 07FF 110xxxxx 10xxxxxx0800 - FFFF 1110xxxx 10xxxxxx 10xxxxxx 例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001，用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。 可见UTF-8是变长的，将Unicode编码为00000000-0000007F的字符，用单个字节来表示； 00000080-000007FF的字符用两个字节表示；00000800-0000FFFF的字符用3字节表示。因为目前为止Unicode-16规范没有指定FFFF以上的字符，所以UTF-8最多是使用3个字节来表示一个字符。但理论上来说，UTF-8最多需要用6字节表示一个字符。 UTF-8兼容ASCII。 #utf16编码utf-16 和unicode规范是一致的，所以不兼容ascii。以上信息来源参考：","categories":[],"tags":[]},{"title":"jquery学习笔记2(效果)","slug":"web/jquery2","date":"2016-10-23T03:12:00.000Z","updated":"2019-01-26T05:01:23.044Z","comments":true,"path":"2016/10/23/web/jquery2/","link":"","permalink":"http://wedvefv.github.io/2016/10/23/web/jquery2/","excerpt":"","text":"##jquery隐藏和显示hide/show函数: $(“p”).show(); 或者$(“p”).hide();toggle()函数 切换隐藏和显示。 ##jquery淡入淡出fadeIn(speed,callback) 渐渐显示(淡入)fadeOut(…) 渐渐显示(淡出)fadeToggle()切换 淡入淡出fadeTo(速度，透明度，callback) 调整透明度0-1之间值 ##jquery滑动效果像投影屏幕收起或下拉一样的效果slideDown() 滑下面板slideUp() 收起面板slideToggle() 切换Down/up ##jquery 动画操作$(selector).animate({params},speed,callback); 例如：123456789101112$(\"button\").click(function()&#123; $(\"div\").animate(&#123;left:'250px'&#125;);&#125;);或者 多个属性操作$(\"button\").click(function()&#123; $(\"div\").animate(&#123; left:'250px', opacity:'0.5', height:'150px', width:'150px' &#125;);&#125;); ##jquery停止动画 stop函数,或者带参数$(selector).stop(stopAll,goToEnd);stopall参数默认false，表示只停止当前动画，队列中其他的动画继续执行goToEnd参数默认false表示，不立即完成当前动画，多个动画时，多次点击能依次停止各个动画 ##jquery callback函数 许多jquery动画函数会有speed参数或者duration(持续) slow/fast/normal然后第二个参数写一个回调函数，动画完成后会执行。 ##jquery的Chaining(链式)操作可以接连在一个元素上执行多个函数操作，这样就不用寻找同一个元素多次。俗称：链式操作例如：12$(\"##p1\").css(\"color\",\"red\").slideUp(2000).slideDown(2000);//p元素变红色，然后上滑，再下滑","categories":[{"name":"web","slug":"web","permalink":"http://wedvefv.github.io/categories/web/"}],"tags":[]},{"title":"atom编辑器","slug":"vim/atom","date":"2016-10-09T07:30:30.000Z","updated":"2018-05-26T02:38:14.915Z","comments":true,"path":"2016/10/09/vim/atom/","link":"","permalink":"http://wedvefv.github.io/2016/10/09/vim/atom/","excerpt":"","text":"atom 编辑器比较：优点：开源，免费，可定制型强，中文支持比sublime做的好，sublime是收费的。缺点：稍微有一点慢，相对于sublime，画面类似sublime，体积也比较大。 发展： vim基本都是插件扩展， 插件一般是vimscript编写，现在为了可维护性，加入python支持。 sublime：也是插件扩展，主要是json配置，可扩展性没atom好。收费，维护仅由编写者维护。 atom：开源，界面类似sublime，插件脚本由js编写，利于扩展，社区支持强大。有人说atom是编辑器 的集大成者。 windows下安装 需要node.js支持（安装了node.js ，安装npm包管理器（为了解决nodejs代码的部署问题）） 安装atom编辑器 打开编辑器，packages-&gt;settings-view-&gt;manager packages ,安装插件即可。 网络被公司设置代理的，需要设置~/.atom/.apmrc 文件如下：123strict-ssl=falsehttp-proxy=http://xxxx:xxhttps-proxy=https://xxxx:xx 有些时候还是提示 atom.io:433访问地址错误。 那么可以登录：https://atom.io/packages/ 搜索需要的插件，进入Repo页面。复制 git需要的地址。例如qolor插件地址：https://github.com/DavidLGoldberg/qolor.git 进入~/.atom/packages目录下, 打开cmd，执行git clone https://github.com/DavidLGoldberg/qolor.git cd qolor 进入qolor目录，在执行npm install 就会安装 qolor插件了。 npm如果需要设置代理，配置文件是~/.npmrc ，写入： 12registry=http://registry.cnpmjs.org/proxy=http://xxx:xx 测试环境 windows 8.1 nodejs-4.6.0 python2.7.9 ~表示用户目录。我的是 c:/users/administrator/","categories":[{"name":"atom","slug":"atom","permalink":"http://wedvefv.github.io/categories/atom/"}],"tags":[]},{"title":"nerdtree插件","slug":"vim/vim_nerdtree","date":"2016-10-06T12:07:30.000Z","updated":"2018-05-26T02:38:14.915Z","comments":true,"path":"2016/10/06/vim/vim_nerdtree/","link":"","permalink":"http://wedvefv.github.io/2016/10/06/vim/vim_nerdtree/","excerpt":"","text":"#nerdtree插件，可以在vim左侧显示目录 使用说明1、在linux命令行界面，输入vim 2、输入 :NERDTree ，回车 3、进入当前目录的树形界面，通过小键盘上下键，能移动选中的目录或文件 4、目录前面有+或者&gt;号，摁Enter会展开目录，文件前面是-号，摁Enter会在右侧窗口展现该文件的内容，光标自动移到右侧文件窗口。 5、ctr+w+h 光标移到左侧树形目录，ctrl+w+l 光标移到右侧文件显示窗口。多次摁 ctrl+w，光标自动在左右侧窗口切换 6、光标focus左侧树形窗口，摁? 弹出NERDTree的帮助，再次摁？关闭帮助显示 7、输入:q回车，关闭光标所在窗口 进阶用法o 打开关闭文件或者目录t 在标签页中打开T 在后台标签页中打开! 执行此文件p 到上层目录P 到根目录K 到第一个节点J 到最后一个节点u 打开上层目录m 显示文件系统菜单（添加、删除、移动操作）? 帮助q 关闭","categories":[{"name":"vim","slug":"vim","permalink":"http://wedvefv.github.io/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://wedvefv.github.io/tags/vim/"}]},{"title":"ajax简介","slug":"web/ajax","date":"2016-10-06T12:04:30.000Z","updated":"2018-05-26T02:38:14.916Z","comments":true,"path":"2016/10/06/web/ajax/","link":"","permalink":"http://wedvefv.github.io/2016/10/06/web/ajax/","excerpt":"","text":"1.ajax 简介ajax = 异步javascript+XMLAAJAX是基于现有的Internet标准，并且联合使用它们：XMLHttpRequest 对象 (异步的与服务器交换数据)JavaScript/DOM (信息显示/交互)CSS (给数据定义样式)XML (作为转换数据的格式)lamp AJAX应用程序与浏览器和平台无关的！实现不刷新整个页面，实现页面动态更新的技术。 ajax工作原理： 2.ajax实例 1.首先建立XMLHttpRequest对象，区分不同的浏览器版本，IE5,IE6不支持直接建立XMLHttpRequest对象，所以： 12345678var xmlhttp;if(window.XMLHttpRequest)&#123; //如果为真，则支持XMLHttpRequest对象 xmlhttp = new XMLHttpRequest();&#125;else&#123; //code for IE5,6 xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\";)&#125; 2.XMLHttpRequest对象用于和服务器交换数据 open方法用于发送请求，参数1：方法，参数2：url，参数3:异步/同步 xmlhttp.open(“GET”,”ajax_info.txt”,true) send方法也用于请求，不过只支持post请求，参数：string xmlhttp.send(string); GET和POST的区别： GET更简单，更快，大部分情况都能用。以下情况使用POST： 无法使用缓存文件更新服务器上的文件或数据库。 发送大量数据到服务器。 发送用户输入的未知字符到服务器时。 例子get请求：12xmlhttp.open(\"GET\",\"demo_get2.html?fname=Henry&amp;lname=Ford\",true);xmlhttp.send(); post请求： 如果post表单那样的提交数据，需要添加http头12345678910xmlhttp.open(\"POST\",\"ajax_test.html\",true);xmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");xmlhttp.send(\"fname=Henry&amp;lname=Ford\");setRequestHeader方法：setRequestHeader(header,value) 向请求添加 HTTP 头。header: 规定头的名称value: 规定头的值 Async=true 使用XMLRequest.open()方法时，一般在ajax第三个参数必须是true（异步）而且规定请求就绪时执行的函数。也就是定义 XMLHttpRequest.onreadystatechange 事件函数。当请求完成时，触发该函数，类似定时器。 因为web请求也许需要一段时间，所以发送异步请求，等待请求的这段时间可以执行其他代码。请求得到返回时，再执行onreadystatechange中的函数。 12345678910xmlhttp.onreadystatechange=function() // &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)//请求正确返回http code 200时 //执行修改id为mydiv的html元素内容。 &#123; document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; &#125; &#125;xmlhttp.open(\"GET\",\"ajax_info.txt\",true); //请求ajax_info.txt文件，xmlhttp.send(); #Async=false 不推荐，对于小型的请求也下可以。因为javascript会等待服务器返回后才继续向下执行。如果服务器繁忙，应用程序会挂起或者挂掉。 XMLHttpRequest响应如果返回200,就可以使用","categories":[{"name":"web","slug":"web","permalink":"http://wedvefv.github.io/categories/web/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://wedvefv.github.io/tags/ajax/"}]},{"title":"DLL导出方法","slug":"windows/dll_export","date":"2016-10-06T12:04:30.000Z","updated":"2019-01-26T05:01:37.181Z","comments":true,"path":"2016/10/06/windows/dll_export/","link":"","permalink":"http://wedvefv.github.io/2016/10/06/windows/dll_export/","excerpt":"","text":"DLL导出方法dll导出方法1 ：模块定义def文件，不支持c++的重载，以c的方式编译，导出的函数名不被修改，这样显示调用dll取得函数地址就没事。提供给vb，python等语言,需要_stdcall约定(函数自己清理堆栈)，这样无论是c文件还是c++文件，导出函数都会被改名字。所以dll做成必须要用def文件，否则找不到名字。除非你记得修饰过的函数名。 dll导出方法2：函数声明头文件声明如下：__declspec(dllexport)这种方式，方便c++代码的重载，同名函数不同参数，导出名字会被修饰，所以能区分开。这种方式实现了DLL的隐式调用（只提供dll的导出符号lib文件，就可直接调用函数，（只是导出函数符号，没有具体实现，不同于静态库的lib文件），def文件导出的dll不能用隐式调用，只能取得函数地址getProcAddress方式） 1234567891011121314151617181920212223#ifndef _EXSOPINF_H_#define _EXSOPINF_H_#ifdef __cplusplus //cpp文件时，用c方式编译导出，不会修改导出函数名。但是_stdcall//调用也会修改，_cdecl(默认)调用不会修改extern \"C\" &#123;#endif__declspec(dllexport) DWORD WINAPI function1( LPCSTR lpszFolderName, LPSTR lpszCode );__declspec(dllexport) DWORD WINAPI function2( LPCSTR lpszFolderName, LPSTR lpszCode );#ifdef __cplusplus&#125;#endif#endif函数定义时，也需要在函数名前：加入修饰__declspec(dllexport) DWORD WINAPI function1(LPCSTR lpszFolderName, LPSTR lpszCode )&#123; return 0;&#125;其中WINAPI是调用约定。 常见调用约定123456789101112131415161718192021222324252627282930调用协议常用场合__stdcall：Windows API默认的函数调用协议。__cdecl：C/C++默认的函数调用协议。__fastcall：适用于对性能要求较高的场合。函数参数入栈方式__stdcall：函数参数由右向左入栈。__cdecl：函数参数由右向左入栈。__fastcall：从左开始不大于4字节的参数放入CPU的ECX和EDX寄存器，其余参数从右向左入栈。问题一：__fastcall在寄存器中放入不大于4字节的参数，故性能较高，适用于需要高性能的场合。栈内数据清除方式__stdcall：函数调用结束后由被调用函数清除栈内数据。__cdecl：函数调用结束后由函数调用者清除栈内数据。__fastcall：函数调用结束后由被调用函数清除栈内数据。问题一：不同编译器设定的栈结构不尽相同，跨开发平台时由函数调用者清除栈内数据不可行。问题二：某些函数的参数是可变的，如printf函数，这样的函数只能由函数调用者清除栈内数据。问题三：由调用者清除栈内数据时，每次调用都包含清除栈内数据的代码，故可执行文件较大。C语言编译器函数名称修饰规则__stdcall：编译后，函数名被修饰为“_functionname@number”。__cdecl：编译后，函数名被修饰为“_functionname”。__fastcall：编译后，函数名给修饰为“@functionname@nmuber”。注：“functionname”为函数名，“number”为参数字节数。注：函数实现和函数定义时如果使用了不同的函数调用协议，则无法实现函数调用。C++语言编译器函数名称修饰规则__stdcall：编译后，函数名被修饰为“?functionname@@YG******@Z”。__cdecl：编译后，函数名被修饰为“?functionname@@YA******@Z”。__fastcall：编译后，函数名被修饰为“?functionname@@YI******@Z”。注：“******”为函数返回值类型和参数类型表。注：函数实现和函数定义时如果使用了不同的函数调用协议，则无法实现函数调用。C语言和C++语言间如果不进行特殊处理，也无法实现函数的互相调用。 _stdcall与_cdecl的区别(函数调用方式)(1). 是C Declaration的缩写，表示C语言默认的函数调用方法，实际上也是C++的默认的函数调用方法。(2). 所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。具体所示：调用方的函数调用-&gt;被调用函数的执行-&gt;被调用函数的结果返回-&gt;调用方清除调整堆栈。(3). 被调用函数无需要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。总的来说函数的参数个数可变的(就像printf函数一样)，因为只有调用者才知道它传给被调用函数几个参数，才能在调用结束时适当地调整堆栈。(4). 因为每个调用的地方都需要生成一段调整堆栈的代码，所以最后生成的文件较大。 _stdcall(CALLBACK/WINAPI)(1). 是Standard Call的缩写，要想函数按照此调用方式必须在函数名加入stdcall，通常 win32 api 应该是_stdcall调用规则。通过VC++编写的DLL欲被其他语言编写的程序调用，应将函数的调用方式声明为_stdcall 方式，WINAPI都采用这种方式。(2). 所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是this指针。具体所示：调用方的函数调用-&gt;被调用函数的执行-&gt; 被调用方清除调整堆栈-&gt;被调用函数的结果返回。(3). 这些堆栈中的参数由被调用的函数在返回后清除，使用的指令是 retn X，X表示参数占用的字节数，CPU在ret之后自动弹出X个字节的堆栈空间。称为自动清栈。(4). 函数在编译的时候就必须确定参数个数，并且调用者必须严格的控制参数的生成，不能多，不能少，否则返回后会出错。总的来说，就是函数的参数个数不能是可变的。是从 _cdecl 修改而来, _stdcall 不支持可变参数,并且清栈由被调用者负责,其他的都一样(5). 因为只需在被调用函数的地方生成一段调整堆栈的代码，所以最后生成的文件较小。 PASCAL 是Pascal语言的函数调用方式，也可以在C/C++中使用，参数压栈顺序与前两者相反。返回时的清栈方式忘记了。。。 _fastcall 是编译器指定的快速调用方式。由于大多数的函数参数个数很少，使用堆栈传递比较费时。因此_fastcall通常规定将前两个（或若干个）参数由寄存器传递，其余参数还是通过堆栈传递。不同编译器编译的程序规定的寄存器不同。返回方式和_stdcall相当。 _thiscall 是为了解决类成员调用中this指针传递而规定的。_thiscall要求把this指针放在特定寄存器中，该寄存器由编译器决定。VC使用ecx，Borland的C++编译器使用eax。返回方式和_stdcall相当。 _fastcall 和 _thiscall涉及的寄存器由编译器决定，因此不能用作跨编译器的接口。所以Windows上的COM对象接口都定义为_stdcall调用方式。 C中不加说明默认函数为_cdecl方式（C中也只能用这种方式），C++也一样，但是默认的调用方式可以在IDE环境中设置。 带有可变参数的函数必须且只能使用_cdecl方式，例如下面的函数: int printf(char * fmtStr, …); int scanf(char * fmtStr, ...); 函数名修饰(1). _cdecl ：对于_cdecl而言，如果对于定义在C程序文件(编译器会通过后缀名为.C判断)的输出函数，函数名会保持原样；对于定义在C++程序文件中的输出函数，函数名会被修饰(见10)。为使函数名不被修饰，有两种方法：A.可通过在前面加上extern “c”以去除函数名修饰；B. 可通过.def文件去除函数名修饰。 (2). _stdcall：无论是C程序文件中的输出函数还是C++程序文件中的输出函数，函数名都会被修饰。对于定义在C++程序文件中的输出函数，好像更复杂，和_cdecl的情况类似。去除函数名修饰方法：只能通过.def文件去除函数名修饰。 函数名修饰规则：(1). 为什么要函数名修饰： 函数名修饰就是编译器在编译期间创建的一个字符串，用来指明函数的定义和原型。LINK程序或其他工具有时需要指定函数的名字修饰来定位函数的正确位置。多少情况下程序员并不需要知道函数的名字修饰，LINK程序或其他工具会自动区分他们。当然，在某些情况下需要指定函数名修饰，例如在c++程序中，为了让LINK程序或其他工具能够匹配到正确的函数名字，就必须为重载函数后一些特殊函数(如构造函数和析构函数)指定名字修饰。另一种需要指定函数名修饰的情况是在汇编程序中调用C或C++函数。(2). C语言： 对于_stdcall调用约定，编译器和链接器会在输出函数名前加上一个下划线前缀，函数名后面加上一个“@”符号和其参数的字节数，例如_functionname@number。_cdecl调用约定仅在输出函数名前加上一个下划线前缀，例如_functionname。_fastcall调用约定在输出函数名前加上一个 “@“符号，后面也是一个”@“符号和其参数的字节数，例如@functionname@number。(3). C++语言： C++的函数名修饰规则有些复杂，但是信息更充分，通过分析修饰名不仅能够知道函数的调用方式，返回值类型，参数个数甚至参数类型。不管cdecl，fastcall还是stdcall调用方式，函数修饰都是以一个“?”开始，后面紧跟函数的名字，再后面是参数表的开始标识和按照参数类型代号拼出的参数表。对于stdcall方式，参数表的开始标识是“@@YG”，对于cdecl方式则是“@@YA”，对于fastcall方式则是“@@YI”。参数表的拼写代号如下所示：X–voidD–charE–unsigned charF–shortH–intI–unsigned intJ–longK–unsigned long（DWORD）M–floatN–double_N—boolU—struct 指针的方式有些特别，用PA表示指针，用PB表示const类型的指针。后面的代号表明指针类型，如果相同类型的指针连续出现，以“0”代替，一个“0”代表一次重复。U表示结构类型，通常后跟结构体的类型名，用“@@”表示结构类型名的结束。函数的返回值不作特殊处理，它的描述方式和函数参数一样，紧跟着参数表的开始标志，也就是说，函数参数表的第一项实际上是表示函数的返回值类型。参数表后以“@Z”标识整个名字的结束，如果该函数无参数，则以“Z”标识结束。下面举两个例子，假如有以下函数声明：int Function1(char *var1,unsigned long);其函数修饰名为“?Function1@@YGHPADK@Z”，而对于函数声明：oid Function2();其函数修饰名则为“?Function2@@YGXXZ” 。对于C++的类成员函数（其调用方式是thiscall），函数的名字修饰与非成员的C++函数稍有不同，首先就是在函数名字和参数表之间插入以“@”字符引导的类名；其次是参数表的开始标识不同，公有（public）成员函数的标识是“@@QAE”,保护（protected）成员函数的标识是“@@IAE”,私有（private）成员函数的标识是“@@AAE”，如果函数声明使用了const关键字，则相应的标识应分别为“@@QBE”，“@@IBE”和“@@ABE”。如果参数类型是类实例的引用，则使用“AAV1”，对于const类型的引用，则使用“ABV1”。 查看函数的名字修饰 有两种方式可以检查你的程序中的函数的名字修饰：使用编译输出列表或使用Dumpbin工具。使用/FAc，/FAs或/FAcs命令行参数可以让编译器输出函数或变量名字列表。使用dumpbin.exe /SYMBOLS命令也可以获得obj文件或lib文件中的函数或变量名字列表。此外，还可以使用 undname.exe 将修饰名转换为未修饰形式。 _beginthread需要_cdecl的线程函数地址，_beginthreadex和_CreateThread需要_stdcall的线程函数地址。1234567#define CALLBACK __stdcall //这就是传说中的回调函数#define WINAPI __stdcall //这就是传说中的WINAPI#define WINAPIV __cdecl#define APIENTRY WINAPI //DllMain的入口就在这里#define APIPRIVATE __stdcall#define PASCAL __stdcall","categories":[{"name":"windows","slug":"windows","permalink":"http://wedvefv.github.io/categories/windows/"}],"tags":[]},{"title":"syntastic vim  静态分析插件","slug":"vim/vim_syntastic","date":"2016-10-05T12:10:30.000Z","updated":"2018-05-26T02:38:14.913Z","comments":true,"path":"2016/10/05/vim/vim_syntastic/","link":"","permalink":"http://wedvefv.github.io/2016/10/05/vim/vim_syntastic/","excerpt":"","text":"syntastic vim 静态分析插件，里面带有各种语言的分析工具，是为了代码补全提示1234567891011121314配置如下：_vimrc文件加入：Bundle 'scrooloose/syntastic'打开vim： BundleInstall 安装插件。配置如下：let g:syntastic_error_symbol='&gt;&gt;'let g:syntastic_warning_symbol='&gt;'let g:syntastic_check_on_open=1let g:syntastic_check_on_wq=0let g:syntastic_enable_highlighting=1#下面一行是指定使用哪种工具分析python语法和javascript语法let g:syntastic_python_checkers=['pyflakes'] \" 使用pyflakes,速度比pylint快let g:syntastic_javascript_checkers = ['jsl', 'jshint']let g:syntastic_html_checkers=['tidy', 'jshint']","categories":[{"name":"vim","slug":"vim","permalink":"http://wedvefv.github.io/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://wedvefv.github.io/tags/vim/"}]},{"title":"linux常用函数手册","slug":"linux/linux_c_help","date":"2016-10-05T12:06:30.000Z","updated":"2018-05-26T02:38:14.913Z","comments":true,"path":"2016/10/05/linux/linux_c_help/","link":"","permalink":"http://wedvefv.github.io/2016/10/05/linux/linux_c_help/","excerpt":"","text":"linuxlinux常用函数手册","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[]},{"title":"jquery学习笔记1(基础)","slug":"web/jquery1","date":"2016-09-23T03:12:00.000Z","updated":"2019-01-26T05:01:11.606Z","comments":true,"path":"2016/09/23/web/jquery1/","link":"","permalink":"http://wedvefv.github.io/2016/09/23/web/jquery1/","excerpt":"","text":"1.安装jquery就是一个js文件,国内CDN下载 引入：123&lt;head&gt;&lt;script src=\"jquery-1.10.2.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; 2.jquery语法基础语法：$(selector).action()$:定义jqueryselector：查询的html元素action：对元素执行的函数实例：1234$(this).hide() //隐藏当前元素$(\"p\").hide() //隐藏p元素$(\"p.test\").hide() //隐藏class属性是test的&lt;p&gt;元素$(\"#test\").hide() //隐藏所有id为test的元素 文档必须就绪完成才能执行jquery代码，否则操作不存在的元素，就会报错。 12345 $(document).ready(function()&#123; // 开始写 jQuery 代码...&#125;); jquery选择器jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 它基于已经存在的 CSS 选择器，除此之外，它还有一些自定义的选择器。jQuery 中所有选择器都以美元符号开头：$()。 元素选择器 ：依据元素名12345$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"p\").hide(); &#125;);&#125;); id选择器 依据元素id12345$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"#test\").hide(); &#125;);&#125;); class选择器 依据class属性12345$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\".test\").hide(); &#125;);&#125;); 更多实例： 语法 描述 $(“*”) 选取所有元素 $(this) 选取当前html元素 $(“p.intro”) 选取class是intro的p元素 $(“p:first”) 选取第一个p元素 $(“ul li:first”) 选取第一个ul元素的第一个li元素 $(“ul li:first-child”) 选取每个ul的第一个li $(“[href]”) 选取带有href属性的元素 $(“a[target=’blank’]”) 所有target属性是blank的a元素 $(“a[target!=’blank’]”) 所有target属性不是blank的a元素 $(“:button”) 选取所有 type=’button’ 的 \\ 元素 和 \\ 元素 $(“tr:even”) 偶数行 $(“tr:odd”) 奇数行 对于多个页面需要jquery代码文件，需要把你写的jquery代码放到单独文件：12345&lt;head&gt;&lt;script src=\"http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js\"&gt;&lt;\\/script&gt;&lt;script src=\"my_jquery_functions.js\"&gt; &lt;\\/script&gt;&lt;\\/head&gt; jquery 事件 鼠标事件 键盘事件 表单事件 文档/窗口事件 click keypress submit load dblclick keydown change resize mouseenter keyup focus scroll mouseleave blur unload 每个事件都如此：123$(\"p\").dblclick(function()&#123; //选择器+事件+函数部分 $(this).hide();&#125;);","categories":[{"name":"web","slug":"web","permalink":"http://wedvefv.github.io/categories/web/"}],"tags":[]},{"title":"html5标签","slug":"web/html5_tags","date":"2016-08-10T03:30:55.000Z","updated":"2019-01-26T05:00:54.512Z","comments":true,"path":"2016/08/10/web/html5_tags/","link":"","permalink":"http://wedvefv.github.io/2016/08/10/web/html5_tags/","excerpt":"","text":"html5标签总结1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292301. &lt;!----&gt; 注释2. &lt;!DOCTYPE&gt; 定义html文本类型3. &lt;a&gt; 定义超链接4. &lt;abbr&gt; 把一段字符串用缩写表示&lt;abbr title =\"People world\"&gt;PW &lt;/abbr&gt;5. &lt;address&gt; 在article元素内部，表示该文章的作者身份信息6. &lt;applet&gt; 定义嵌入的applet ，html5不支持了。请用object代替7. &lt;acronym&gt; html5不支持了，请用&lt;abbr代替哦8. &lt;area&gt; 标签定义图像映射内部的区域，图像中部分区域可以点击，就是说有链接的9. 两栏式架构 |header---------------------------------------------------------------------------------------|顶部 |nav------------------------------------------------------------------------------------------|外链 |article---包含&lt;section&gt;-----------------&lt;aside&gt;--------------------------|文章主体--段落或章节-侧边栏 |footer---------------------------------------------------------------------------------------|底部 以前都是用&lt;div id=\"header\"&gt; &lt;div id =\"nav\"&gt;...... 这样来定义页面的结构，html5新定义了这些，避免div太多混乱.10. &lt;aside&gt; 可用于文章的侧边栏11. &lt;audio&gt; 定义声音链接12. &lt;b&gt; 定义粗体字体，强调13. &lt;base&gt; 放在head里面，用于页面中的链接的基地址。后面的链接就可以写相对地址了。 比如base =www.xxx000.com/img ,链接一个图片就可以不写全路径，直接src=\"xxx.jpeg\"14. &lt;basefont&gt; html不支持了。设置文档中所有字体的默认颜色，大小15. &lt;bdi&gt; 通过脱离父元素的文本设置方向16. &lt;bdo&gt; 定义文本方向，指定dir属性是rtl还是ltr17. &lt;big&gt; html不支持了。请用css控制 ，制作更大的文本18. &lt;blockquote&gt;摘自另一个源的块引用19. &lt;body&gt; 定义文档主体20. &lt;br &gt; 换行符21. &lt;button&gt; 定义按钮，多种属性，可以是按钮，提交，重置.....22. &lt;canvas&gt; 只是承载图形的容器。需要script脚本绘制图形，然后传给canvas标签中23. &lt;caption&gt; 放在table后面，定义表格的标题的24. &lt;canter&gt; 5不支持了，请用CSS定义居中25. &lt;cite&gt; 定义歌曲，影视，书籍等作品的标题26. &lt;code&gt; HTML5 &lt;em&gt; &lt;strong&gt; &lt;dfn&gt; &lt;code&gt; &lt;samp&gt; &lt;kbd&gt; &lt;var&gt; &lt;cite&gt; 等短标签， 不推荐使用了。css能有更丰富的表现27. &lt;col&gt; 只能在table或者colgroup元素内使用，定义一列或多列表格的属性值。默认 至少一列，只有span属性能用了，其他的用css28. &lt;colgroup&gt; 里面只能有col元素 H5已经不支持大部分属性了，用于对表格中的列进行组合， 并格式化。要区别于col29. &lt;command&gt; 可以指定消息事件处理函数。目前只支持ＩＥ30. &lt;datalist&gt; 定义选项列表。和input元素配合使用，对于输入框提示作用31. &lt;dd&gt; dl定义列表，dt定义项目,dd对项目进行描述32. &lt;del&gt; 定义已经删除的文本。中划线33. &lt;details&gt; 描述文档中的某个细节。目前只chrome支持34. &lt;div&gt; 定义文档中的分割和部分。以便对块元素进行格式化。35. &lt;dl&gt; 定义一个list 配合dt和dd使用。dt是项目。dd是项目具体描述36. &lt;em&gt; 被强调的文本。一般配合css使用啦。37. &lt;embed&gt; 定义嵌入的内容。属性src=\"\"38. &lt;fieldset&gt; 表单中 配合legend标签定义fieldset的标题。相当与通过legend定义的标题话一个框框,\\ 把许多表单元素圈住。39. &lt;figcaptio&gt; 标签定义 figure 元素的标题（caption）。40. &lt;figure&gt; 标签规定独立的流内容（图像、图表、照片、代码等等）。定义的内容与主内容无关， 定义的内容不存在时也不对文档有影响41. &lt;font&gt; H5不支持了，请用CSS42. &lt;footer&gt; 定义页脚，作者信息等等43. &lt;form&gt; form 元素包含一个或多个表单元素，比如： button input keygen object output select textarea44. &lt;frame&gt; H5不支持了。45. &lt;frameset&gt; 5也不支持了。46. &lt;h1-h6&gt; 定义标题大小47. &lt;head&gt; 头部元素，下面是可用在 head 部分的标签： base link meta script style title48. &lt;header&gt; 定义文档的页眉49. &lt;hgroup&gt; 对标题进行组合 .H5的新标签50. &lt;hr&gt; 定义主题变化，表现为一条水平线。51. &lt;html&gt; 定义html文档52. &lt;i&gt; 斜体。应该使用CSS53. &lt;iframe&gt; 创建包含另个文档的内嵌框架。54. &lt;img&gt; 必须要的两个属性src和alt（指定图片表述，以备图片无法加载时显示文字）55. &lt;input&gt; 定义用户的输入字段，根据不同的 type 属性，输入字段有多种形态。输入字段可以是 文本字段、复选框、密码字段、单选按钮、按钮等等。56. &lt;ins&gt; 地难以插入文本，一般和del一起使用。ins定义的文字会加入下划线57. &lt;keygen&gt; 类似input,定义表单的密钥生成器字段。H5新标签58. &lt;kbd&gt; 表示文本是键盘输入的59. &lt;label&gt; input标签配合使用。点击label标签定义的文字，相当与自动点击input控件60. &lt;legend&gt; 给一下元素定义标题的：&lt;fieldset&gt;、&lt;figure&gt;、&lt;details&gt;。61. &lt;li&gt; 定义列表项。在&lt;ul&gt;标签和&lt;ol&gt;标签中使用/有序和无序列表62. &lt;link&gt; 文档链接外部资源的。大部分用来链接外部样式表css文件63. &lt;map&gt; 定义图像区域映射，name属性和ｉｍｇ的usemap属性关联，包含area元素。64. &lt;mark&gt; 突出显示文本。文本背景黄色。65. &lt;menu&gt; 标签定义菜单列表。用于排列表单控件 &lt;menu&gt; &lt;li&gt;&lt;input type=\"checkbox\" /&gt;Red&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\" /&gt;blue&lt;/li&gt; &lt;/menu&gt;67. &lt;meta&gt; 定义页面相关信息。位于head中定义关键词，利于搜索引擎检索： &lt;meta name=\"keywords\" content=\"HTML, CSS, XML, XHTML, JavaScript\" /&gt; 定义对页面的描述： &lt;meta name=\"description\" content=\"w3c html web 技术标准教程。\" /&gt; 每５秒刷新一次页面： &lt;meta http-equiv=\"refresh\" content=\"5\" /&gt;68. &lt;meter&gt; 定义度量范围，可以用属性,max/min 也可以用文本中定义范围。69. &lt;nav&gt; 定义导航栏的链接的部分70. &lt;noframes&gt; H5不支持了，用于不能显示框架的时候提示文本71. &lt;noscript&gt; 当不支持脚本时。显示提示的文本72. &lt;object&gt; 定义一个嵌入的对象，多媒体等。图像请使用ｉｍｇ代替。大部分html4中的属性H5不支持了。73. &lt;ol&gt; 有序列表74. &lt;optgroup&gt; 组合选项： &lt;select&gt; &lt;optgroup label=\"Swedish Cars\"&gt; &lt;option value =\"volvo\"&gt;Volvo&lt;/option&gt; &lt;option value =\"saab\"&gt;Saab&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=\"German Cars\"&gt; &lt;option value =\"mercedes\"&gt;Mercedes&lt;/option&gt; &lt;option value =\"audi\"&gt;Audi&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt;75. &lt;optlon&gt; 定义一个下拉列表选项：76. &lt;select&gt; &lt;option value=\"volvo\"&gt;Volvo&lt;/option&gt; &lt;option value=\"saab\"&gt;Saab&lt;/option&gt; &lt;option value=\"opel\" selected=\"selected\"&gt;Opel&lt;/option&gt; &lt;option value=\"audi\"&gt;Audi&lt;/option&gt; &lt;/select&gt;76. &lt;output&gt; 标签定义不同类型的输出，比如脚本的输出。: &lt;form oninput=\"x.value=parseInt(a.value)+parseInt(b.value)\"&gt;0&lt;input type=\"range\" id=\"a\" value=\"50\"&gt;100+&lt;input type=\"number\" id=\"b\" value=\"50\"&gt; =&lt;output name=\"x\" for=\"a b\"&gt;&lt;/output&gt; &lt;/form&gt; 计算0-100的随机数加50＝多少，&lt;input type=\"range\" id=\"a\" value=\"50\"&gt;表示一个随机滚动条。77. &lt;p&gt; 段落78. &lt;param&gt; http://www.w3chtml.com/html5/tag/param.html79. &lt;pre&gt; 文本原样输出。不会改变格式80. &lt;progress&gt; 表示时间函数有关的进度条： &lt;progress&gt; &lt;span id=\"objprogress\"&gt;85&lt;/span&gt;% &lt;/progress&gt;81. &lt;q&gt; 短引用，cite属性指定来源地址，显示是会插入了一个引号，表示后面的内容是引用的内容。82. &lt;rp&gt; 指示不支持ruby元素时，显示的文本注释83. &lt;ruby&gt; 显示中文注音或者字符。里面用&lt;rt&gt;和&lt;rp&gt;元素包裹。84. &lt;s&gt; 增加删除线文本。H5不支持了。请用css，85. &lt;samp&gt; 如下标签都是不推荐使用的，请用css样式表，更好。 &lt;em&gt; 呈现为被强调的文本。 &lt;strong&gt; 定义重要的文本。 &lt;dfn&gt; 定义一个定义项目。 &lt;code&gt; 定义计算机代码文本。 &lt;samp&gt; 定义样本文本。 &lt;kbd&gt; 定义键盘文本。它表示文本是从键盘上键入的。它经常用在与计算机相关的文档或手册中。 &lt;var&gt; 定义变量。您可以将此标签与 &lt;pre&gt; 及 &lt;code&gt; 标签配合使用。 &lt;cite&gt; 定义引用。可使用该标签对参考文献的引用进行定义，比如书籍或杂志的标题。86. &lt;script&gt; javascript脚本置于其中。可链接外部ｊｓ脚本，一般脚本用于图像操作，表单验证和动态内容更改。87. &lt;select&gt; 多个option标签置于其中，形成选择下拉列表。88. &lt;small&gt; 小型文本，一般作为旁注信息89. &lt;source&gt; 多媒体资源标签： &lt;audio controls&gt; &lt;source src=\"horse.ogg\" type=\"audio/ogg\"&gt; &lt;source src=\"horse.mp3\" type=\"audio/mpeg\"&gt; Your browser does not support the audio element. &lt;/audio&gt;90 .&lt;span&gt; 对文档中行内元素进行分组。一遍对单独的一组文本进行样式控制。91 .&lt;strike&gt; 加删除线。请用del代替。不建议使用，用css吧92. &lt;strong&gt; 加粗文本93. &lt;style&gt; html插入样式信息标签。94 .&lt;sub&gt; 定义上标文本，相当于脚注信息95. &lt;summary&gt; &lt;datails&gt;元素的地一个元素，定义details的标题内容。96. &lt;sup&gt; 定义上标文本，相当于脚注信息97. &lt;table&gt; 定义表格 &lt;tr&gt;定义一行,&lt;th&gt;定义表的第一行头。&lt;td&gt;定义表的内容 &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;月份&lt;/th&gt; &lt;th&gt;存款&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;一月&lt;/td&gt; &lt;td&gt;1000 元&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;98. &lt;tbody&gt; 表格的正文部分。H５已废除99. &lt;td&gt; 表格内容行100. &lt;textarea&gt; 文本域，相当于MFC中的编辑框101. &lt;tfoot&gt; 表格的页脚部分，H5已废除102. &lt;th&gt; 表格的头一行103. &lt;thead&gt; 表格的头部分，需要有tr行104. &lt;time&gt; 定义时间或者日期，目前浏览器还都不支持105 .&lt;title&gt; 浏览器显示的标题106. &lt;tr&gt; 定义表格中的行107. &lt;track&gt; 为视频媒体文件制定外部文本轨道。比如字幕啥的。目前浏览器还不要支持此标签。 &lt;video width=\"320\" height=\"240\" controls=\"controls\"&gt; &lt;source src=\"forrest_gump.mp4\" type=\"video/mp4\" /&gt; &lt;source src=\"forrest_gump.ogg\" type=\"video/ogg\" /&gt; &lt;track kind=\"subtitles\" src=\"subs_chi.srt\" srclang=\"zh\" label=\"Chinese\"&gt; &lt;track kind=\"subtitles\" src=\"subs_eng.srt\" srclang=\"en\" label=\"English\"&gt; &lt;/video&gt;108. &lt;tt&gt; 定义打印机文本。目前h5已经不支持了。109. &lt;u&gt; 下划线。目前已不支持110. &lt;ul&gt; 无需列表。111. &lt;var&gt; 定义变量。您可以将此标签与 &lt;pre&gt; 及 &lt;code&gt; 标签配合使用。112. &lt;video&gt; 视频标签： &lt;video src=\"movie.ogg\" controls=\"controls\"&gt; 您的浏览器不支持 video 标签。 &lt;/video&gt;113. &lt;wbr&gt; 标志在何处适合加入换行符，避免有些单词加入换行符没拆开，不明意义。114. &lt;rt&gt; 在ruby元素中加入汉字的注音： &lt;ruby&gt; 漢 &lt;rt&gt; ㄏㄢˋ &lt;/rt&gt; &lt;/ruby&gt;115. &lt;section&gt; 定义区段。页眉，页脚.......116. &lt;label&gt; 定义一个选项组的标注","categories":[{"name":"web","slug":"web","permalink":"http://wedvefv.github.io/categories/web/"}],"tags":[{"name":"html5","slug":"html5","permalink":"http://wedvefv.github.io/tags/html5/"}]},{"title":"windowFTP的建立","slug":"windows/windowsFTP","date":"2016-07-31T07:30:55.000Z","updated":"2018-05-26T02:38:14.919Z","comments":true,"path":"2016/07/31/windows/windowsFTP/","link":"","permalink":"http://wedvefv.github.io/2016/07/31/windows/windowsFTP/","excerpt":"","text":"windows下建立ftp服务器需要单独建立一个用户，然后把特定目录设置为ftp目录（单独的用户需要有访问权限哦），这样避免别人知道你的计算机用户名和密码。可以把新建的这个用户名密码告诉他们。别的目录不属于这个用户的文件夹，他就没法访问了。。 运行：appwiz.cpl 添加ftp服务组件右键计算机 -管理-服务应用程序管理-IIS管理 ，添加ftp站点上传目录：一步一步设置，IP ,ftp上传目录，点口为21 ，基本，权限：可读可写，用户：所有用户，ssL可选，证书 ,完成。 下载目录：IP ，端口2121 ，用户：所有用户，SSL可选，基本，权限：可读，完成。 注意如果你使用的用户是administrator ，需要FTP上传目录和下载目录，添加用户权限，加入新建的用户。 windows下访问，可在文件浏览器输入ftp://IP 默认端口21linux下访问 ,当前目录home/username/ ,输入ftp ip port 提示输入ftp服务器的用户名和密码提示 user logged in。ls 可显示ftp上面的文件和文件夹。下载文件: get xxx ./（/home/username/）上传文件: cd 进入到ftp的目录11/ cd 11 然后 put home/username/index.php ,就把index.php上传了。。","categories":[{"name":"windows","slug":"windows","permalink":"http://wedvefv.github.io/categories/windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://wedvefv.github.io/tags/windows/"}]},{"title":"LinuxFTP的建立","slug":"linux/LinuxFTP","date":"2016-07-31T03:30:55.000Z","updated":"2018-10-20T16:38:57.314Z","comments":true,"path":"2016/07/31/linux/LinuxFTP/","link":"","permalink":"http://wedvefv.github.io/2016/07/31/linux/LinuxFTP/","excerpt":"","text":"linux FTP建立，条件：安装vsftpd：配置vsftpd的配置文件：vim /etc/vsftpd.conf anonymous_enbale =NO //关闭匿名登录local_enbale=YES //允许本地用户，就是ftp建立者的用户名和密码write_enbale=YES //允许写入，就是上传文件到ftp 反注释掉：ascii_upload_enbale=YESascii_download_enbale=YES 默认的ftp目录就是home下的user目录，包含桌面，下载等等文件夹。","categories":[{"name":"linux","slug":"linux","permalink":"http://wedvefv.github.io/categories/linux/"}],"tags":[]},{"title":"非对称加密(公钥加密)","slug":"windows/public_key_encryption","date":"2016-07-21T06:35:58.000Z","updated":"2019-01-26T05:02:17.346Z","comments":true,"path":"2016/07/21/windows/public_key_encryption/","link":"","permalink":"http://wedvefv.github.io/2016/07/21/windows/public_key_encryption/","excerpt":"","text":"公钥加密的工作原理 对称加密：1* 加密密钥和解密密钥是一样的。 非对称加密：12* (也叫公钥加密)* 两个密钥在加密和解密中配合使用，密钥对具有特殊的互补关系，密钥对在数学上存在特殊关系。 邮件的电子签名过程： 12* 捕获邮件正文--&gt;计算邮件哈希值--&gt;检索发件人私钥--&gt;用发件人私钥加密哈希值--&gt;附加到邮件底部(明文签名)/与原始邮件组合成二进制附件(不透明签名)--&gt;发送mail* --私钥只有发件人才唯一拥有，公钥仅仅与一个私钥关联，所以可以用公钥唯一识别一个私钥。 验证邮件签名的过程：1234* 接收邮件--&gt;检索加密的哈希值--&gt;检索邮件正文--&gt;用正文计算邮件哈希值--&gt;检索发件人的公钥--&gt;用发件人公钥解密签名(加密的哈希值)--&gt;和计算的哈希值对比--&gt;验证签名邮件* --文件内容不变，计算的哈希值就不会变。* --私钥加密的东西，需要对应的公钥解密。* --如果哈希值一致，说明公钥对应的私钥是对的，私钥只有发件人知道，所以确定发件人属实。 邮件内容的加密123* 对称密钥加密的话，需要\"密钥协商\"，必须协商出一个双方都知道的密钥。* 非对称密钥加密的话，没有协商过程，因为一个公钥，可以很多人拥有，私钥是只有一个人有。* 由于非对称(公钥加密)密钥加密使用密钥对，加密和解密是一个昂贵的计算过程，速度慢。所以这么做呗...... send加密mail内容1* -- 1.找到邮件正文--&gt;2.检索收件人公钥--&gt;3.生成一次性的会话密钥(这个是对称密钥)--&gt;4.用会话密钥加密正文--&gt;5.用收件人公钥加密会话密钥，并附到邮件--&gt;6.发送邮件 recv解密mail内容1* -- 1.接收邮件--&gt;2.检索加密邮件正文和会话密钥-&gt;3.检索收件人私钥解密会话密钥-&gt;4.用解密的会话密钥解密正文-&gt;5.解密邮件返回给收件人 同时使用签名和邮件内容加密 同时使用签名和邮件内容加密后的解密 功能和所需的密钥表","categories":[{"name":"windows","slug":"windows","permalink":"http://wedvefv.github.io/categories/windows/"}],"tags":[{"name":"encrypt","slug":"encrypt","permalink":"http://wedvefv.github.io/tags/encrypt/"}]},{"title":"c++格式化I/O","slug":"c/c++io","date":"2016-06-29T04:55:59.000Z","updated":"2018-05-26T02:38:14.914Z","comments":true,"path":"2016/06/29/c/c++io/","link":"","permalink":"http://wedvefv.github.io/2016/06/29/c/c++io/","excerpt":"","text":"使用函数模板12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;iomanip&gt;using namepsace std;int main()&#123; char bookname[100],double price ,int counts; cout&lt;&lt;\"请输入书名：\"&lt;&lt;endl; cin&gt;&gt;bookname; cout&lt;&lt;\"请输入单价：\"&lt;&lt;endl; cin&gt;&gt;price; cout&lt;&lt;\"请输入销售数量：\"&lt;&lt;endl; cout&lt;&lt;\"使用标志和成员函数进行格式化输出：\"&lt;&lt;endl; cout&lt;&lt;\"《\"&lt;&lt;bookname&lt;&lt; \"》：\"; cout.width(5); cout.fill('*'); cout&lt;&lt;price &lt;&lt;\"单价\"; cout.self(ios::scientific); cout.precision(3); cout&lt;&lt;price*counts&lt;&lt;\"销售额\"; cout.self(ios::showpos|ios::left); cout&lt;&lt;counts&lt;&lt;\"销售数量：\"&lt;&lt;endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://wedvefv.github.io/categories/c/"}],"tags":[]},{"title":"windows时间的处理","slug":"windows/win_time_func","date":"2016-06-28T06:33:59.000Z","updated":"2019-01-26T05:01:47.195Z","comments":true,"path":"2016/06/28/windows/win_time_func/","link":"","permalink":"http://wedvefv.github.io/2016/06/28/windows/win_time_func/","excerpt":"","text":"windows时间的处理：系统时间： UTC时间（格林威治时间）,世界标准时间，北京时间是UTC+8 本地时间： UTC时间+时区偏差，就是计算机右下角显示的时间 文件时间：类型有三种 1.创建时间 2.访问时间 3.修改时间 文件时间是： 64位的值记录了自1601年1月1日0点以来的以100纳秒（ns）为单位的格林威治时间间隔，我们鼠标右键查看文件属性，看到的是这个间隔加上时区差的，并且显示格式的SYSTEM结构体形式(年月日的形式)，不是FILETIME结构体形式（两个DWORD成员）。所以看起来跟本地时间差别不大。 基本概念先来看看这两个结构体的定义： FILETIME结构体:1234typedef struct _FILETIME &#123; DWORDdwLowDateTime; DWORDdwHighDateTime;&#125; FILETIME, *PFILETIME, *LPFILETIME; 它在MSDN上的说明——Contains a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC时间). SYSTEMTIME结构体：12345678910111213141516171819typedef struct _SYSTEMTIME &#123; WORDwYear; WORDwMonth; WORDwDayOfWeek; WORDwDay; WORDwHour; WORDwMinute; WORDwSecond; WORDwMilliseconds;&#125; SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME; 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include \"stdafx.h\"#include &lt;windows.h&gt; #include &lt;stdio.h&gt; //#include &lt;conio.h&gt; class CLocaltimeAndFiletime &#123; public: static void GetCurrentLocalTime(char *pstrDate, char *pstrTime); static void FileTimeToLocalTime(FILETIME &amp;ft, char *pstrDate, char *pstrTime); &#125;; //取得：本地时间 = UTC+8（北京的） //UTC是系统时间void CLocaltimeAndFiletime::GetCurrentLocalTime(char *pstrDate, char *pstrTime) &#123; SYSTEMTIME st; GetLocalTime(&amp;st); //取得本地时间 //getsystemtime(&amp;st) //依据所在时区，和本地时间，推算出UTC时间=本地-8小时 if (pstrDate != NULL) sprintf(pstrDate, \"%d-%d-%d\", st.wYear, st.wMonth, st.wDay); if (pstrTime != NULL) sprintf(pstrTime, \"%02d:%02d:%02d\", st.wHour, st.wMinute, st.wSecond); &#125; //把一个64e位的文件时间（三种类型，创建/访问/修改），转换成SYSTEEMTIME结构类型void CLocaltimeAndFiletime::FileTimeToLocalTime(FILETIME &amp;ft, char *pstrDate, char *pstrTime) &#123; FILETIME localft; //文件时间是1601年--目前的UTC时间的差（64位整数），转换成UTC+本地时区的64位值， FileTimeToLocalFileTime(&amp;ft, &amp;localft); SYSTEMTIME st; FileTimeToSystemTime(&amp;localft, &amp;st); //转换成年月日形式 if (pstrDate != NULL) sprintf(pstrDate, \"%d-%d-%d\", st.wYear, st.wMonth, st.wDay); if (pstrTime != NULL) sprintf(pstrTime, \"%02d:%02d:%02d\", st.wHour, st.wMinute, st.wSecond); &#125; int main(int argc, char *argv[]) &#123; printf(\"windows(FILETIME和SYSTEMTIME) \\n\"); const int MAX_LEN = 30; char strDate[MAX_LEN], strTime[MAX_LEN]; CLocaltimeAndFiletime::GetCurrentLocalTime(strDate, strTime); printf(\"current: %s %s\\n\", strDate, strTime); const char* pstrFileName = \"C:\\\\1.html\"; printf(\"文件名：%s\\n\", pstrFileName); //打开一个文件取得句柄，利用这个句柄取得文件的时间属性（创建，访问，修改） HANDLE handleFile = CreateFile(pstrFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL); FILETIME ftCreationTime, ftLastAccessTime, ftLastWriteTime; //取得时间属性 GetFileTime(handleFile, &amp;ftCreationTime, &amp;ftLastAccessTime, &amp;ftLastWriteTime); //转换创建时间 CLocaltimeAndFiletime::FileTimeToLocalTime(ftCreationTime, strDate, strTime); printf(\"create: %s %s\\n\", strDate, strTime); //转换最后一次访问时间 CLocaltimeAndFiletime::FileTimeToLocalTime(ftLastAccessTime, strDate, strTime); printf(\"access: %s %s\\n\", strDate, strTime); //转换修改时间 CLocaltimeAndFiletime::FileTimeToLocalTime(ftLastWriteTime, strDate, strTime); printf(\"modify: %s %s\\n\", strDate, strTime); //getch(); return 0; &#125;","categories":[{"name":"windows","slug":"windows","permalink":"http://wedvefv.github.io/categories/windows/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://wedvefv.github.io/tags/c/"}]},{"title":"git 配置文件","slug":"git/git_1_config","date":"2016-06-28T06:33:58.000Z","updated":"2018-05-26T02:38:14.912Z","comments":true,"path":"2016/06/28/git/git_1_config/","link":"","permalink":"http://wedvefv.github.io/2016/06/28/git/git_1_config/","excerpt":"","text":"基于公司是代理上网的，所以配置windows下的.gitconfig文件如下：1234567[http] proxy = 代理ip:代理port[user] email = xxxxx@gmail.com name =xxxxxhhh [gui] encoding = utf-8 #代码库统一使用utf-8 由于本人电脑是日语版OS，所以GIT终端显示中文字体是乱码，所以索性设置全部使用utf-8编码。","categories":[{"name":"git","slug":"git","permalink":"http://wedvefv.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://wedvefv.github.io/tags/git/"}]}]}