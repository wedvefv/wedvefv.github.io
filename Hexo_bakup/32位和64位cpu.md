+++
title="32位cpu为什么只能寻址4G空间"
categories=["linux"]
tags=["cpu"] 
date="2021-08-19 12:00:00+0800"
toc=true
+++

# 不同架构的cpu

## 16位cpu

int是2个字节

long是4个字节

## 32位cpu

Int 是4个字节

long是4个字节

只能装**32**位操作系统



## 64位cpu

int是4个直接（为了兼容32程序）

long是8个字节

可以装**32**位系统或者**64**位系统。



## time_t为什么是long

因为时间戳是10位，目前来说必须要4个字节才能表示(-2147483648 --2147483647 ) 也就是(-2^32) - (2^31-1)

16位时期 int是2字节，long是4字节，所以 time_t才是long;

# 内存寻址范围范围和cpu架构的关系

## 32位cpu为什么内存只能用4G

因为32的cpu，设计的寄存器位宽就是32，因为寄存器要放**指针**(地址)，地址最大值只能是2^32（4294967296）

4294967296 换算成计算机里面的存储单位:

​	4G = (4 * 1024)MB = (4 * 1024 * 1024)KB = (4*1024 * 1024 * 1024)b

**所以我们说32位机器只能用4G内存条，装个8G的也是浪费，这就是由于寄存器构造决定的，最大地址就是0xffffffff (8个f, 32位)**



## 内存是如何存放数据的

内存的物理模型可以理解为海量的小格子，一个格子是1bit，只能放0和1

但是cpu不是一个bit一个bit的去读取，而是8个bit当做一个整体去访问（也就是一字节，byte），所以说每个地址都是指向这某一个字节的。

为什么cpu有地址就能访问到数据呢? 因为我们定义时指定了类型，比如char就是一个字节，int是4个字节，也就值告诉cpu读取字节的长度，所以cpu知道什么时候结束。

字符串char* s 是连续的字节，所以规定结尾使用\0来标志字符串的结束。

