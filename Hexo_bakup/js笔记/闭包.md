+++
title="如何解释js闭包"
categories=["js"] 
tags=["js"] 
date="2020-03-06 14:47:30+0800"
toc=true
+++

## 看个例子
```js
function assert (condition, msg) {
	if (condition) {
		console.log(msg, '')
	} else {
		console.log(error, '')
	}
}

var outerValue = "samurai";
var later;

function outerFunc() {
	var innerValue = "ninja";
	function innerFunc(){
	   var a = 90;
		assert(outerValue === "samurai", "i can see your");
		assert(innerValue === "ninja", "i can see the ninja");
	}
	later = innerFunc;
}

function animate() {
	var timer = setInterval(function () {
		console.log('time-----', '')
	},5)

}
outerFunc();
later();

```
   - later和outerFunc函数都属于全局作用域
   - innerValue和innerFunc是属于outerFunc函数作用域
   - outerFunc实例对象是不能访问y的，但是创建内部函数innerFunc和getx时就创建了一个包，这个包像气泡一样把innerValue和innerFunc封装在了一起, 通过外部变量引用函数内部方法
   - 类比一下c++
      - outerFunc像是C++的类
      - innerValue就像C++的私有成员
      - innerFunc像是类内部的成员方法。
      - 如果不用this.xxx 接收内部函数，只能由外部变量later 指向内部函数，否则无法访问。
      
   - 为什么new这个函数之后，就可以用later调用访问函数了呢？
      - new 的作用
         - 创建空对象，把引用地址赋给this，继承原型
         - 通过this添加属性和方法到对象
         - 返回this实例(如果没手动返回别的对象）

### 上下文环境
   -  通过执行上下文跟踪程序执行位置
       - 有一个上下文执行栈结构，首先加入全局上下文环境
       - new时加入outerFunc函数上下文环境
       - 调用later时加入innerFunc函数上下文环境
   - ![](/img/js/context.png)

### 查找要访问的变量的路径
   - 词法环境主要是基于代码嵌套结构决定的。
   - 词法环境实际是js作用域的实际控制人
   - 每个函数上下文都有一个词法环境
   - 词法环境包含这个上下文标识符的映射表
   - outerFunc 包含innerValue和innerFunc映射
   - innerFunc 包含a变量
   - 同时包含对上级词法环境的引用。
   - 基于上下文调用栈的顺序，结合每个函数上下文的映射表和对==上级环境的引用==顺序从当前环境向上查找变量。
   - ![](/img/js/jsvalue.png)

### 当前上下文是如何包含上级环境的引用的呢？
   - 得益于js中函数是第一型对象
   - 函数创建时，就会创建与之关联的词法环境，并存储到内部属性[[Environment]]上，所以才可以向上逐层访问外部环境，查找变量。
 


### 定义变量的关键字和词法环境
   - ES6之前只有全局变量和函数局部变量, 都用var。
   - ES6引入了let和const俩关键字。
   - var
      - var 可以是全局的，函数内部的，或者for循环条件中的
      - for循环内部中的var，在循环外部也是可以访问的
      - var 忽略了块作用域， 所以引入了const和let
   - let 
      - 限定的范围，只能作用与最近的块作用域
   - const  不能修改的变量
   

### 总结一下
   - 闭包实际就是你调用一个嵌套的内部函数时
   - 内部函数实际上包含对上层函数所在环境的引用； 所以能访问上层函数的一些变量，从而达到保护这个变量，只能通过函数访问的目的。
   - 可能是javascript本身设计的问题，导致后续需要c++,java 这些语言的一些特性，才有了闭包这样的特性，最终目的其实是一样的。
